<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Reconstruction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.transform</a> &gt; <span class="el_source">Reconstruction.java</span></div><h1>Reconstruction.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.transform;

import algorithms.dimensionReduction.CURDecomposition;
import algorithms.dimensionReduction.CURDecomposition.CUR;
import algorithms.imageProcessing.features.RANSACSolver;
import algorithms.imageProcessing.matching.ErrorType;
import algorithms.imageProcessing.transform.Camera.CameraExtrinsicParameters;
import algorithms.imageProcessing.transform.Camera.CameraIntrinsicParameters;
import algorithms.imageProcessing.transform.Camera.CameraParameters;
import algorithms.imageProcessing.transform.Camera.CameraProjection;
import static algorithms.imageProcessing.transform.CameraPose.eps;
import algorithms.matrix.LinearEquations;
import algorithms.matrix.MatrixUtil;
import algorithms.matrix.MatrixUtil.SVDProducts;
import algorithms.util.FormatArray;
import java.util.Arrays;
import java.util.List;
import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.EVD;
import no.uib.cipr.matrix.NotConvergedException;
import no.uib.cipr.matrix.SymmDenseEVD;

/**
 * given correspondence between two images calculate the camera
 * parameters as intrinsic and extrinsic parameters,
 * and the real world position.
 * 
 * Euler rotations:
        
        about z-axis (yaw):           about x-axis (roll):       about the y-axis (pitch):
            | cos φ   -sin φ    0 |    |    1       0       0 |  |  cos ψ    0  sin ψ |
            | sin φ    cos φ    0 |    |    0   cos θ   sin θ |  |      0    1      0 |
            |     0        0    1 |    |    0  -sin θ   cos θ |  | -sin ψ    0  cos ψ |        
        
 * useful reading:
 * &lt;pre&gt;
 * http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
 * add other references here
 * &lt;/pre&gt;
 * @author nichole
 */
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">public class Reconstruction {</span>
    
    /*
    // notes from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
    
    // homogeneous repr of a point is x_vec = (x, y, 1)^T
    // equation f a line is ell = a*x + b*y + c = 0;
    
    // line rewritten in homogeneous coordinatrs is x_vec^T * ell.
    
    // general conic in 3 dimensions is a*x^2 + b*x*y + c*y^2 + d*x*z + e*y*z + f*z^2 = 0.
    //     rewritten using 2D homogenouse coords, quadratice form: x_vec^T * C * x_vec = 0
    //                  [a   b/2   d/2 ]
    //        where C = [b/2   c   c/2 ]
    //                  [d/2 c/2     f ]
    //        C has 6 variable, 5 DOF, so need 5 points
    //     can then reformat x_vec^T * C * x_vec = 0 into
    //        the &quot;design matrix&quot; * &quot;the carrier vector&quot; = 0
    //               A * c = 0
    //        c = SVD(A).V^T[n-1], the eigenvector assoc w/ smallest eigenvalue.
    
    Parallel lines lines intersect in points at infinity (also known as ideal points) 
    and these points have the form (x, y, 0)^⊤
    the set of ideal points (i.e., points at infinity) is the set of points 
    where parallel lines intersect.
    
    The intersection of two lines is given by their vector cross product.
    
    The line passing through any two points is given by their cross product.
    
    The line at infinity is (0,0,1)^⊤ which can be seen by taking the cross
        product of 2 points at infinity.  e.g. (x1,y1,0)^⊤ cross (x2,y2,0)^⊤ = (0,0,1)^⊤
     
        The two circular points are defined as
           I = (1, i, 0)^⊤
           J = (1, −i, 0)^T
        The circular points lie on l∞, along with all other ideal points. All 
        circles intersect l∞ at points I and J.
    
        Recall the duality between points and lines:
           x2 = H*x1,  l2 = (H^−⊤)*l1
    
        The dual of a conic C is the set of lines satisfying:
           l^⊤ * C∗ * l = 0
           where C∗ is the adjoint in this case, so C∗ ∼ C^−1  
        Dual conics tranform under homography H as:
           C∗′ = H * C∗ * H^⊤
    
        The “conic dual to the circular points” is defined as
           C ∞∗ = I*J^⊤ + J*I^⊤
                ~ [ 1  0  0 ]
                  [ 0  1  0 ]
                  [ 0  0  0 ]
    
    Stratified Reconstruction (cahpters 8 and 6):
    
    Notes on stratified reconstruction in the 2D case (lec 6):
        Each stratum represents a different level of reconstruction we may wish 
        to obtain, namely projective, affine and Euclidean. 
        A general 2D homography can be decomposed into three components:
           H = H_p * H_a * H_e 
        which are the projective, affine and euclidean components.
              
          H = [  I   0 ] * [ K    0 ] * [ R   T ]
              [ v^T  1 ]   [ 0^T  1 ]   [ 0^T 1 ]
                 H_p           H_a         H_e
    
          H_e is a 2D rigid transformation
          H_a is an affine trnsformation
          H_p is a projective transformation known as an “elation.”
               v^T affets the line at infinity, l∞ = (0, 0, 1)^⊤.
               ** Only H_p can map l∞ to a finite line in the image plane, or vice versa.
               suppose the image of l∞ is some line l = (a, b, c)^⊤, then the
               following matrix H will send l back to infinity:
                                [ 1  0  0 ]
                      H = H_a * [ 0  1  0 ]
                                [ a  b  c ]
                          where where H_a is any affine transformation
          
       The key to the affine upgrade is the behavior of the line at infinity. 
       The counterpart to this for the Euclidean upgrade is the behavior of the 
       “circular points.”
    
       Chap 6, Section 3 has more about euclidean upgrades in transformation
          for circular points and conics.
    
    Notes from Lec 8:
        Levels of reconstruction of a scene: projective, affine and euclidean components.
    
        If the camera intrinisc parameters, K, are not known, then only the
        projective reconstruction is possible, but this can be upgraded to 
        affine (parallelism preserved) and Euclidean (parallelism and orthogonality preserved) reconstructions.
    
        Given a set of point correspondences between two views {(x′1,x′2)} 
        we can get the Projective Structure X_p.
        where x' = x * K, that is, x = x' * K^-1.  x' are the image coordinates as pixels.
           first calculate F from the point correspondences, then use F to
           get the projection matrix for camera 2, P2, then triangulate to get
           X_p (which is the 3D point in projective space).
           caveat is that K, R, T from in P2 will not be unique.
           The canonical choice for these two projection matrices is:
               P1 = [ I | 0 ]
               P2 = [ ([T']_x)^T  F  | T' ]
           where T' = K*T and ||T'|| = 1
           and recall that T′ ∼ e2
    
           The triangulation uses DLT and SVD.
    
           for the case where there is no noise:
                X_P is SVD(M).V^T[last row]
           for the case where there is noise, the SVD solution is the initial
                values for a non-linear optimization method.
    
    NOTE: to solve affine reconstruction for the case of pure translation, 
    see Example 6.6 of Ma, Soatto, Kosecká, &amp; Shankar Sastry book
    &quot;Invitation to 3D&quot;.
    For the case of pure rotation, see Example 6.10.
    
    */
    
     /**
     * given 2 sets of correspondence from 2 different images taken from
     * 2 cameras whose intrinsic and extrinsic parameters are known,
     * determine the world scene coordinates of the correspondence points.
     * This method simply uses triangulation on each correspondence pair.
     * &lt;pre&gt;
     * following CMU lectures of Kris Kitani at 
     * http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
     * 
     * &lt;/pre&gt;
     * @param camera1 image 1 camera matrices of intrinsic and extrinsic parameters.
     * the size is 3 x 4.
     * @param camera2 image 2 camera matrices of intrinsic and extrinsic parameters.
     * the size is 3 x 4.
     * @param x1 the image 1 set of correspondence points.  format is 3 x N where
     * N is the number of points.
     * @param x2 the image 2 set of correspondence points.  format is 3 x N where
     * N is the number of points.
     * @return the world scene coordinates and the intrinsic and extrinsic
     * camera matrices (the later were given to the code, but are convenient to return in results).
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static ReconstructionResults calculateReconstruction(
        CameraParameters camera1, CameraParameters camera2,
        double[][] x1, double[][] x2) throws NotConvergedException {
        
<span class="nc bnc" id="L188" title="All 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L189">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="nc" id="L191">        int n = x1[0].length;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L193">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
        
        /*
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (3) For each point correspondence, compute the point X in 3D space (triangularization)
        */
                        
<span class="nc" id="L202">        double[][] XW = new double[4][n];</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="nc" id="L204">            XW[i] = new double[n];</span>
        }
        double[] XWPt;
        
<span class="nc" id="L208">        double[][] x1Pt = new double[3][1];</span>
<span class="nc" id="L209">        double[][] x2Pt = new double[3][1];</span>
        int i, j, ii;
<span class="nc bnc" id="L211" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L212">            x1Pt[i] = new double[1];</span>
<span class="nc" id="L213">            x2Pt[i] = new double[1];</span>
        }
                    
<span class="nc bnc" id="L216" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            for (ii = 0; ii &lt; 3; ++ii) {</span>
<span class="nc" id="L218">                x1Pt[ii][0] = x1[ii][i];</span>
<span class="nc" id="L219">                x2Pt[ii][0] = x2[ii][i];</span>
            }
            //length is 4
<span class="nc" id="L222">            XWPt = Triangulation.calculateWCSPoint(camera1, camera2, x1Pt, x2Pt);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            for (ii = 0; ii &lt; 4; ++ii) {</span>
<span class="nc" id="L224">                XW[ii][i] = XWPt[ii];</span>
            } 
        }
                
<span class="nc" id="L228">        ReconstructionResults rr = new ReconstructionResults();</span>
<span class="nc" id="L229">        rr.XW = XW;</span>

<span class="nc" id="L231">        return rr;</span>
    }
    
    /**
     * This is also called Projective Structure From Motion for the
     * Two-camera case.   it's a distorted version of euclidean 3d.
     * 
     * NOTE that because the camera calibration, that is, intrinsic parameters,
     * are not known, only the projective reconstruction is possible,
     * but this can be upgraded to 
     affine (parallelism preserved) and Euclidean (parallelism and orthogonality preserved) 
     reconstructions.
     To upgrade to an affine projection, need 3 vanishing points
     (see Section 9.2.2 of Belongie lec 9).
     To directly upgrade from projective to euclidean projection, need
     5 ground truth points in general position, that is, no 4 points
     are coplanar (see Section 9.3 of Belongie lec 9).
     * NOTE: this solution is fine for cases with no noise, otherwise, the
     * results should be the initial values for a non-linear optimization method.
     
     * The method uses the fundamental matrix to compute the camera matrices P1, P2
     * and then uses triangulation on each correspondence pair.
     * 
     * &lt;pre&gt;
     * following CMU lectures of Kris Kitani at 
     * http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
     * 
     * other references:
     * Sect 7.2.1 of Szeliski 2010
     * &lt;/pre&gt;
     * @param x1 the image 1 set of correspondence points.  format is 3 x N where
     * N is the number of points.
     * NOTE: since intrinsic parameters are not known, users of this method should 
     * presumably center the coordinates in some manner 
     * (e.g. subtract the image center or centroid of points) since internally
     * an identity matrix is used for K.  
     * @param x2 the image 2 set of correspondence points.  format is 3 x N where
     * N is the number of points.
     * NOTE: since intrinsic parameters are not known, users of this method should 
     * presumably center the coordinates in some manner 
     * (e.g. subtract the image center or centroid of points).
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static ProjectionResults calculateProjectiveReconstruction(
        double[][] x1, double[][] x2) throws NotConvergedException {
                        
<span class="nc bnc" id="L277" title="All 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L278">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="nc" id="L280">        int n0 = x1[0].length;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (x2[0].length != n0) {</span>
<span class="nc" id="L282">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (n0 &lt; 7) {</span>
<span class="nc" id="L285">            throw new IllegalArgumentException(&quot;need at least 7 points for the uncalirated camera (s) 2 view solution&quot;);</span>
        }
        
        /*
        Similar to CameraPose.calculateUsingEssentialMatrix()
        except for use of uncalibrated points and use of a different diagonal
        in constrcting the fundamental matrix.
                        
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (1) compute fundamental matrix FM from the correspondence x1, x2
        (2) compute the camera matrices P1, P2 from FM.
        (3) For each point correspondence, compute the point X in 3D space (triangularization)
        
        see also notes above from notes from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
        */
        
<span class="nc" id="L302">        DenseMatrix x1M = new DenseMatrix(x1);</span>
<span class="nc" id="L303">        DenseMatrix x2M = new DenseMatrix(x2);</span>
        
<span class="nc" id="L305">        EpipolarTransformer.NormalizedXY normXY1 = EpipolarTransformer.normalize(x1M);</span>
<span class="nc" id="L306">        EpipolarTransformer.NormalizedXY normXY2 = EpipolarTransformer.normalize(x2M);</span>
<span class="nc" id="L307">        DenseMatrix leftM = normXY1.getXy();</span>
<span class="nc" id="L308">        DenseMatrix rightM = normXY2.getXy();</span>
        
<span class="nc" id="L310">        double tolerance = 3.84; //3.84 5.99 7.82        </span>
<span class="nc" id="L311">        boolean useToleranceAsStatFactor = true;</span>
<span class="nc" id="L312">        ErrorType errorType = ErrorType.SAMPSONS;</span>
<span class="nc" id="L313">        EpipolarTransformationFit fitR = null;</span>
        
<span class="nc" id="L315">        boolean reCalcIterations = true;</span>
        
        //EpipolarTransformer tr = new EpipolarTransformer();
        
        /*
        DenseMatrix normalizedFM = tr.calculateEpipolarProjection(leftM, rightM);
        DenseMatrix vNFM = tr.validateSolution(normalizedFM, leftM, rightM);
        
        Distances distances = new Distances();
        if (useToleranceAsStatFactor) {
            fitR = distances.calculateError2(normalizedFM, leftM, rightM,
                    errorType, tolerance);
        } else {
            fitR = distances.calculateError(normalizedFM, leftM, rightM,
                    errorType, tolerance);
        }
        */
        
<span class="nc" id="L333">        boolean calibrated = false;</span>
                
<span class="nc" id="L335">        RANSACSolver solver = new RANSACSolver();</span>
<span class="nc" id="L336">        fitR = solver.calculateEpipolarProjection(</span>
            leftM, rightM, errorType, useToleranceAsStatFactor, tolerance,
                reCalcIterations, calibrated);
        
<span class="nc" id="L340">        DenseMatrix fm = EpipolarTransformer.denormalizeTheFundamentalMatrix(</span>
<span class="nc" id="L341">            fitR.getFundamentalMatrix(), </span>
<span class="nc" id="L342">            normXY1.getNormalizationMatrices(),</span>
<span class="nc" id="L343">            normXY2.getNormalizationMatrices());</span>
        
<span class="nc" id="L345">        double[][] _fm = MatrixUtil.convertToRowMajor(fm);</span>
        
<span class="nc" id="L347">        x1M = extractIndices(x1M, fitR.inlierIndexes);</span>
<span class="nc" id="L348">        x2M = extractIndices(x2M, fitR.inlierIndexes);</span>
<span class="nc" id="L349">        x1 = MatrixUtil.convertToRowMajor(x1M);</span>
<span class="nc" id="L350">        x2 = MatrixUtil.convertToRowMajor(x2M);</span>
        
<span class="nc" id="L352">        int n = x1[0].length;</span>
        
<span class="nc" id="L354">        System.out.println(&quot;RANSAC fit=&quot; + fitR.toString());</span>
        
        //(2) compute the camera matrices P1, P2 from FM.
        
<span class="nc" id="L358">        MatrixUtil.SVDProducts svdF = MatrixUtil.performSVD(_fm);</span>
        
<span class="nc bnc" id="L360" title="All 6 branches missed.">        assert(svdF.u[0].length == 3 &amp;&amp; svdF.u.length == 3);</span>
        
<span class="nc" id="L362">        double detU = MatrixUtil.determinant(svdF.u);</span>
<span class="nc" id="L363">        double detV = MatrixUtil.determinant(svdF.vT);</span>
        
<span class="nc" id="L365">        System.out.printf(&quot;SVD.u=\n%s\n&quot;, FormatArray.toString(svdF.u, &quot;%.3e&quot;));</span>
<span class="nc" id="L366">        System.out.printf(&quot;SVD.s=\n%s\n&quot;, FormatArray.toString(svdF.s, &quot;%.3e&quot;));</span>
<span class="nc" id="L367">        System.out.printf(&quot;SVD.vT=\n%s\n&quot;, FormatArray.toString(svdF.vT, &quot;%.3e&quot;));</span>
<span class="nc" id="L368">        System.out.printf(&quot;det(SVD.u)=%.2f\n&quot;, detU);</span>
<span class="nc" id="L369">        System.out.printf(&quot;det(SVD.vT)=%.2f\n&quot;, detV);</span>
        
        //H = +U * R_Z(+-90)^T * sigma_hat * V^T
<span class="nc" id="L372">        double[][] r90T = new double[3][3];</span>
<span class="nc" id="L373">        r90T[0] = new double[]{0, 1, 0};</span>
<span class="nc" id="L374">        r90T[1] = new double[]{-1, 0, 0};</span>
<span class="nc" id="L375">        r90T[2] = new double[]{0, 0, 1};</span>
        
<span class="nc" id="L377">        double[][] h = MatrixUtil.multiply(</span>
<span class="nc" id="L378">            MatrixUtil.multiplyByDiagonal(</span>
<span class="nc" id="L379">                MatrixUtil.multiply(svdF.u, r90T),</span>
                new double[]{svdF.s[0], svdF.s[1], svdF.s[2]}),
            svdF.vT);
        
        // last column in u is the second epipole and is the direction of vector t
<span class="nc" id="L384">        double[] t1 = MatrixUtil.extractColumn(svdF.u, 2);</span>
<span class="nc" id="L385">        double[] e2 = t1;</span>
<span class="nc" id="L386">        double[] e1 = svdF.vT[2];</span>
        
<span class="nc" id="L388">        System.out.printf(&quot;e1=%s\n&quot;, FormatArray.toString(e1, &quot;%.3e&quot;));</span>
<span class="nc" id="L389">        System.out.printf(&quot;e2=%s\n&quot;, FormatArray.toString(e2, &quot;%.3e&quot;));</span>
         
        // camera matrix P for left image = [I | 0 ]
<span class="nc" id="L392">        double[][] camera1 = MatrixUtil.zeros(3, 4);</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L394">            camera1[i][i] = 1;</span>
        }
        
        // Szeliksi 2010 eqn 7.34:  P0 =[I|0] and P0 =[H|e],
        //    and then he finishes w/ triangulation
        // kitani lecture has P2 = [ [e1]_x * F | e2 ]
        // Hartley &amp; Zisserman: has P2 = [ -[e2]_x^T * F | e2 ]
        //    note that slide 59 of http://16720.courses.cs.cmu.edu/lec/sfm.pdf
        //    also uses the Hartley &amp; Zisserman: version of P2 and refers to proof in 
        //    Forsyth &amp; Ponce Sec 8.3
        // Belongie uses P2 = [ [e2]_x^T * F | e2 ] and so does Ma et al. textbook (msks, &quot;Invitation to 3D&quot;
        // 
        
        // NOTE: not necessary to normalize the epipoles by the last value
        
<span class="nc" id="L409">        double[][] camera2 = MatrixUtil.zeros(3, 4);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L411">            camera2[i] = new double[4];</span>
<span class="nc" id="L412">            System.arraycopy(h[i], 0, camera2[i], 0, 3);</span>
<span class="nc" id="L413">            camera2[i][3] = e2[i];</span>
        }
        
<span class="nc" id="L416">        System.out.printf(&quot;Szeliski P2\n%s\n&quot;, FormatArray.toString(camera2, &quot;%.3e&quot;));</span>
        
<span class="nc" id="L418">        CameraProjection P1 = new CameraProjection(camera1);</span>
<span class="nc" id="L419">        CameraProjection P2 = new CameraProjection(camera2);</span>
        
        double[][] XW;
        double[] XWPt;
<span class="nc" id="L423">        XW = new double[4][n];</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="nc" id="L425">            XW[i] = new double[n];</span>
        }
        
<span class="nc" id="L428">        double[][] x1Pt = new double[3][1];</span>
<span class="nc" id="L429">        double[][] x2Pt = new double[3][1];</span>
        int i, j;
<span class="nc bnc" id="L431" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L432">            x1Pt[i] = new double[1];</span>
<span class="nc" id="L433">            x2Pt[i] = new double[1];</span>
        }
        
<span class="nc bnc" id="L436" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L438">                x1Pt[j][0] = x1[j][i];</span>
<span class="nc" id="L439">                x2Pt[j][0] = x2[j][i];</span>
            }
<span class="nc" id="L441">            XWPt = Triangulation.calculateWCSPoint(P1, P2, x1Pt, x2Pt);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            for (j = 0; j &lt; 4; ++j) {</span>
<span class="nc" id="L443">                XW[j][i] = XWPt[j];</span>
            }
        }
        
<span class="nc" id="L447">        System.out.printf(&quot;Szeliski reconstruction\n%s\n&quot;, FormatArray.toString(XW, &quot;%.3e&quot;));</span>
        
<span class="nc" id="L449">        ProjectionResults rr = new ProjectionResults();</span>
<span class="nc" id="L450">        rr.XW = XW;</span>
<span class="nc" id="L451">        rr.projectionMatrices = MatrixUtil.zeros(3*2, 4);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L453">            System.arraycopy(P1.getP()[i], 0, rr.projectionMatrices[i], 0, 4);</span>
        }
<span class="nc bnc" id="L455" title="All 2 branches missed.">        for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L456">            System.arraycopy(P2.getP()[i], 0, rr.projectionMatrices[3 + i], 0, 4);</span>
        }
<span class="nc" id="L458">        return rr;</span>
    }
   
    /**
     * TODO: proof read the algorithm and write test for this.
     * for the case of un-calibrated cameras viewing the same scene features,
     * recover the 3-D coordinates in WCS and the projection matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * 
     * The method implements the Sturm &amp; Triggs 1996 algorithm: 
     &quot;a method for the recovery of projective shape and motion from multiple 
     images of a scene by the factorization of a matrix containing the images 
     of all points in all views. This factorization is only possible when the
     image points are correctly scaled. The major technical contribution of 
     this paper is a practical method for the recovery of these scalings, 
     using only fundamental matrices and epipoles estimated from the image data.&quot;
     &quot;[it is a] closed form solutions, not iterative bundle-adjustment...&quot;
     * &lt;pre&gt;
     * references:
     * 
     * Sturm and Triggs 1996, 
    &quot;A Factorization Based Algorithm for Multi-Image Projective Structure and Motion&quot;
     https://link.springer.com/content/pdf/10.1007/3-540-61123-1_183.pdf
    
    see also proj_recons_fsvd.m from http://lear.inrialpes.fr/people/triggs/src/
    which has a very liberal copyright in the file COPYRIGHT
    Copyright Bill Triggs (http://www.inrialpes.fr/movi/people/Triggs),
    INRIA (http://www.inria.fr) and CNRS (http://www.cnrs.fr),
    1995-2002. All rights reserved.

    You may use and distribute [*] this work with or without modification,
    for any purpose and without fee or royalty, subject to the following
    conditions:
       (see file COPYRIGHT)
    
     * &lt;/pre&gt;
     * 
     * NOTE: Sturm &amp; Triggs 1996 state in their code, &quot;% The projective output 
     frame is numerically well-conditioned, but otherwise *completely* 
     arbitrary. It has *no* relation to any Euclidean frame.
     * 
     * @param x the image coordinates of feature correspondences in 2 or more
     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates
     * and row 1 holds the y-coordinates and each image's features are given
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static ProjectionResults calculateProjectiveReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                        
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L514">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L517">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="nc" id="L519">        int nFeatures = x[0].length / mImages;</span>
        
        // need at least 7 points in each image for the point version of fundamental
        // matrix.
        // not implementing the line version as Triggs in another paper states
        //    that they may be more affected by outliers
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (nFeatures &lt; 7) {</span>
<span class="nc" id="L526">            throw new IllegalArgumentException(&quot;need at least 7 points per image&quot;);</span>
        }
        
        /*
        3.3 Outline of the Algorithm
        The complete algorithm is composed of the following steps.
        i. Normalize the image coordinates, by applying transformations Ti.
        2. Estimate the fundamental matrices and epipoles with the method of [Har95].
        3. Determine the scale factors Aip using equation (3).
        4. Build the rescaled measurement matrix W.
        5. Balance W by column-wise and &quot;triplet-of-rows&quot;-wise scalar mutliplications.
        6. Compute the SVD of the balanced matrix W.
        7. From the SVD, recover projective motion and shape.
        8. Adapt projective motion, to account for the normalization transformations Ti of
        step 1.
        */
                
        // following proj_recons_fsvd.m
        //    pairs of image sets can be formed either by using the first
        //    image as x1 for all images, or chaining them all together.
        // i.e. [(0,1), (0, 2), (0,3)] or [(0,1), (1,2), (2,3)].
        // choosing the later here.
        
<span class="nc" id="L549">        RANSACSolver ransac = new RANSACSolver();</span>
<span class="nc" id="L550">        double[] e12 = new double[3];</span>
        EpipolarTransformationFit fit;
        double[][] fm;
<span class="nc" id="L553">        ErrorType errorType = ErrorType.DIST_TO_EPIPOLAR_LINE;</span>
<span class="nc" id="L554">        boolean useToleranceAsStatFactor = true;</span>
<span class="nc" id="L555">        double tolerance = 3.84;</span>
        // TODO: estimate this:
<span class="nc bnc" id="L557" title="All 6 branches missed.">        boolean recalcIterations = (nFeatures &gt; 100 || (mImages &gt; 10 &amp;&amp; nFeatures &gt; 20));</span>
<span class="nc" id="L558">        boolean calibrated = false;</span>
        
        int i, j;
        // image pairs extracted from x:
        double[][] x1, x2;
        // the normalization centroidX, centroidY, and sigma values applied to x1 and x2:
<span class="nc" id="L564">        double[] tt = new double[3*mImages];</span>
        
        // use a reference depth of 1 for first image's features, as have no measurements for any depths to bootstrap from.
<span class="nc" id="L567">        double[][] lambdas = MatrixUtil.zeros(mImages, nFeatures);</span>
<span class="nc" id="L568">        Arrays.fill(lambdas[0], 1.);</span>
        
<span class="nc" id="L570">        x1 = extractAndNormalize(x, 0, nFeatures, tt);</span>
        DenseMatrix x1M, x2M;
<span class="nc" id="L572">        x1M = new DenseMatrix(x1);</span>
<span class="nc" id="L573">        double[] x1p = new double[3];</span>
<span class="nc" id="L574">        double[] x2p = new double[3];</span>
        double[] x2e, tmp;
        double tmp2, x2esq;
        
        // format x into shape W (3*mImages X nFeatures):
        //  row 0:2 = image 1 points where row 0 is the x coordinates, row 1 is the y coordinates
        //  row 3:5 = image 2 points
<span class="nc" id="L581">        double[][] w = MatrixUtil.zeros(3*mImages, nFeatures);</span>
<span class="nc" id="L582">        System.arraycopy(x1[0], 0, w[0], 0, nFeatures);</span>
<span class="nc" id="L583">        System.arraycopy(x1[1], 0, w[1], 0, nFeatures);</span>
<span class="nc" id="L584">        System.arraycopy(x1[2], 0, w[2], 0, nFeatures);</span>
        
<span class="nc bnc" id="L586" title="All 2 branches missed.">        for (i = 1; i &lt; mImages; ++i) {</span>
            
<span class="nc" id="L588">            x2 = extractAndNormalize(x, i, nFeatures, tt);</span>
<span class="nc" id="L589">            x2M = new DenseMatrix(x2);</span>
            
<span class="nc" id="L591">            System.arraycopy(x2[0], 0, w[i*3], 0, nFeatures);</span>
<span class="nc" id="L592">            System.arraycopy(x2[1], 0, w[i*3+1], 0, nFeatures);</span>
<span class="nc" id="L593">            System.arraycopy(x2[2], 0, w[i*3+2], 0, nFeatures);</span>
            
<span class="nc" id="L595">            fit = ransac.calculateEpipolarProjection(x1M, x2M, errorType, </span>
                useToleranceAsStatFactor, tolerance, recalcIterations, calibrated);
            
<span class="nc" id="L598">            fm = MatrixUtil.convertToRowMajor(fit.getFundamentalMatrix());</span>
            
            /*
            TODO: consider keeping only the inliers in a future version that handles
            occlusion.  by imputation or applied factorization or other means...
            x1M = extractIndices(x1M, fitR.inlierIndexes);
            x2M = extractIndices(x2M, fitR.inlierIndexes);
            x1 = MatrixUtil.convertToRowMajor(x1M);
            x2 = MatrixUtil.convertToRowMajor(x2M);
            int nFeaturesI = x1[0].length;
            */
            
            // note: e12 is not normalized by last component
<span class="nc" id="L611">            calculateLeftEpipole(fit.getFundamentalMatrix(), e12);</span>
            
<span class="nc bnc" id="L613" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L614">                extractColumn(x1, j, x1p);</span>
<span class="nc" id="L615">                extractColumn(x2, j, x2p);</span>
                
                //xe = cross(x2_j, e12);  // same as x2 cross -e21
<span class="nc" id="L618">                x2e = MatrixUtil.crossProduct(x2p, e12);</span>
                
                //lambda(i,j) = lambda(x1,j) * abs((x1_j' * FM * xe) / (xe' *xe));
                //    note: epipolar line2 = x1_j' * FM
<span class="nc" id="L622">                x2esq = MatrixUtil.innerProduct(x2e, x2e);</span>
                
<span class="nc" id="L624">                tmp = MatrixUtil.multiplyRowVectorByMatrix(x1p, fm);</span>
                
<span class="nc" id="L626">                tmp2 = MatrixUtil.innerProduct(tmp, x2e);</span>
<span class="nc" id="L627">                lambdas[i][j] = lambdas[i-1][j] * Math.abs(tmp2/x2esq);</span>
            }
            
<span class="nc" id="L630">            x1 = x2;</span>
<span class="nc" id="L631">            x1M = x2M;</span>
        }
        
        /*
        4. Build the rescaled measurement matrix W.
        5. Balance W by column-wise and &quot;triplet-of-rows&quot;-wise scalar mutliplications.
        
        as stated in Sturm &amp; Triggs 1996 Section 3.2, the balancing of the
        rescaled measurement matrix by Q's then P's can be replaced by
        balancing the m x n matrix lambdas instead of W because of the simplification
        of working with normalized image coordinates Q.
        The balance operations are demonstrated in proj_recons_fsvd.m
        */
<span class="nc" id="L644">        double eps = 1.e-11;</span>
        double[] lambdaj;
        int k;
        // authors find 2 iterations is heuristically enough:
<span class="nc bnc" id="L648" title="All 2 branches missed.">        for (i = 0; i &lt; 2; ++i) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L650">                lambdaj = MatrixUtil.extractColumn(lambdas, j);</span>
<span class="nc" id="L651">                tmp2 = MatrixUtil.lPSum(lambdaj, 2);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (Math.abs(tmp2) &lt; eps) { </span>
<span class="nc" id="L653">                    tmp2 = eps;</span>
                }
<span class="nc bnc" id="L655" title="All 2 branches missed.">                for (k = 0; k &lt; mImages; ++k) {</span>
<span class="nc" id="L656">                    lambdas[k][j] = lambdaj[k] / tmp2;</span>
                }
            }
<span class="nc bnc" id="L659" title="All 2 branches missed.">            for (k = 0; k &lt; mImages; ++k) {</span>
<span class="nc" id="L660">                tmp2 = MatrixUtil.lPSum(lambdas[k], 2);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (Math.abs(tmp2) &lt; eps) { </span>
<span class="nc" id="L662">                    tmp2 = eps;</span>
                }
<span class="nc" id="L664">                MatrixUtil.multiply(lambdas[k], 1./tmp2);</span>
            }
        }
        
        // rescale the image points
<span class="nc bnc" id="L669" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            for (j = 0; j &lt; nFeatures; ++j) {</span>
<span class="nc" id="L671">                w[3*i + 0][j] *= lambdas[i][j];</span>
<span class="nc" id="L672">                w[3*i + 1][j] *= lambdas[i][j];</span>
<span class="nc" id="L673">                w[3*i + 2][j] *= lambdas[i][j];</span>
            }
        }
        
        /*
        6. Compute the SVD of the balanced matrix W.
        7. From the SVD, recover projective motion and shape.
        8. Adapt projective motion, to account for the normalization transformations Ti of
        step 1.
        */
        
        // if the number of images is larger than 10 or the number of features
        //   is greater than 30, will use cur decomposition
        double[][] u, vT;
        double[][] s;
        //double[][] wRescaled;
<span class="nc bnc" id="L689" title="All 4 branches missed.">        if (mImages &gt; 10 || nFeatures &gt; 30) {</span>
<span class="nc" id="L690">            CUR cur = CURDecomposition.calculateDecomposition(w, 4);</span>
<span class="nc" id="L691">            SVDProducts curSVD = cur.getApproximateSVD();</span>
<span class="nc" id="L692">            u = curSVD.u;</span>
<span class="nc" id="L693">            vT = curSVD.vT;</span>
<span class="nc" id="L694">            s = curSVD.sigma;</span>
            
            // Sturm &amp; Triggs divide by the largest eigenvalue:
<span class="nc" id="L697">            MatrixUtil.multiply(s, 1./s[0][0]);</span>
            
            //wRescaled = cur.getResult();
<span class="nc" id="L700">        } else {</span>
<span class="nc" id="L701">            SVDProducts svd = MatrixUtil.performSVD(w);</span>
            
            //reduce rank to 4
<span class="nc" id="L704">            u = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 3);</span>
<span class="nc" id="L705">            vT = MatrixUtil.copySubMatrix(svd.vT, 0, 3, 0, svd.vT[0].length-1);</span>
            
<span class="nc" id="L707">            s = MatrixUtil.zeros(4, 4);</span>
<span class="nc" id="L708">            s[0][0] = svd.s[0];</span>
<span class="nc" id="L709">            s[1][1] = svd.s[1];</span>
<span class="nc" id="L710">            s[2][2] = svd.s[2];</span>
<span class="nc" id="L711">            s[3][3] = svd.s[3];</span>
            
            /*double[][] sqrts4 = MatrixUtil.zeros(4, 4);
            sqrts4[0][0] = Math.sqrt(svd.s[0]);
            sqrts4[1][1] = Math.sqrt(svd.s[1]);
            sqrts4[2][2] = Math.sqrt(svd.s[2]);
            sqrts4[3][3] = Math.sqrt(svd.s[3]);

            u = MatrixUtil.multiply(u4, sqrts4);
            vT = MatrixUtil.multiply(sqrts4, vT4);
            wRescaled = MatrixUtil.multiply(u, vT);
            */
            
            // Sturm &amp; Triggs divide by the largest eigenvalue:
<span class="nc" id="L725">            MatrixUtil.multiply(s, 1./s[0][0]);</span>
        }
        
        //Ps = fliplr(U(:,1:4));             // 3*MImages X 4
        //Xs = flipud(S(1:4,1:4)*V(:,1:4)'); // 4 X 4*mImages
<span class="nc" id="L730">        double[][] ps = MatrixUtil.copy(u);</span>
<span class="nc" id="L731">        MatrixUtil.flipLR(ps);</span>
<span class="nc" id="L732">        double[][] XW = MatrixUtil.multiply(s, vT);</span>
<span class="nc" id="L733">        MatrixUtil.flipUD(XW);</span>
   
        //denormalize ps.  = ps * T^-1
        // tt is the normalization centroidX, centroidY, and sigma values applied to x1 and x2:
        /*
                 | 1  0  xc |   | s  0   0 |   | s   0  xc |
          T^-1 = | 0  1  yc | * | 0  s   0 | = | 0   s  yc |
                 | 0  0   1 |   | 0  0   1 |   | 0   0   1 |
        */
<span class="nc" id="L742">        double[][] tInv = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L743">        tInv[2][2] = 1;</span>
        double ts, txc, tyc;
        double[] p0, p1, p2;
<span class="nc" id="L746">        double[][] p = MatrixUtil.zeros(3, 4);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L748">            txc = tt[3*i];</span>
<span class="nc" id="L749">            tyc = tt[3*i + 1];</span>
<span class="nc" id="L750">            ts = tt[3*i + 2];</span>
<span class="nc" id="L751">            tInv[0][0] = ts;</span>
<span class="nc" id="L752">            tInv[1][1] = ts;</span>
<span class="nc" id="L753">            tInv[0][2] = txc;</span>
<span class="nc" id="L754">            tInv[1][2] = tyc;</span>
            
<span class="nc" id="L756">            p0 = ps[3*mImages];</span>
<span class="nc" id="L757">            p1 = ps[3*mImages + 1];</span>
<span class="nc" id="L758">            p2 = ps[3*mImages + 2];</span>
<span class="nc" id="L759">            System.arraycopy(p0, 0, p[0], 0, 4);</span>
<span class="nc" id="L760">            System.arraycopy(p1, 0, p[1], 0, 4);</span>
<span class="nc" id="L761">            System.arraycopy(p2, 0, p[2], 0, 4);</span>
            
<span class="nc" id="L763">            p = MatrixUtil.multiply(p, tInv);</span>
            
<span class="nc" id="L765">            System.arraycopy(p[0], 0, ps[3*mImages], 0, 4);</span>
<span class="nc" id="L766">            System.arraycopy(p[1], 0, ps[3*mImages + 1], 0, 4);</span>
<span class="nc" id="L767">            System.arraycopy(p[2], 0, ps[3*mImages + 2], 0, 4);</span>
        }
        
<span class="nc" id="L770">        ProjectionResults rr = new ProjectionResults();</span>
<span class="nc" id="L771">        rr.XW = XW;</span>
<span class="nc" id="L772">        rr.projectionMatrices = ps;</span>
        
<span class="nc" id="L774">        return rr;</span>
    }
    
     /**
     * given correspondence between two images in image coordinates calculate 
     * the extrinsic camera parameters and the 3-D points.
     * 
     * This method calculates the essential matrix and uses the SVD of it to
     * extract the translation and possible rotation matrices which are
     * filtered to find the best while calculating triangulation for each point.
     * 
     * Note that the absolute translation between the two cameras can never be 
     * recovered from pure image measurements alone, regardless of how many 
     * cameras or points are used as ground control points are
     * needed.
     * &lt;pre&gt;
     * following CMU lectures of Kris Kitani at 
     http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
     Szeliski 2010, Chapter 7, and eqn (7.25).
     Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;, pg 121 
     * &lt;/pre&gt;
     * @param k1 intrinsic camera matrix for image 1 in units of pixels.
     * @param k2 intrinsic camera matrix for image 2 in units of pixels.
     * @param x1 the image 1 set of correspondence points in image reference frame.  
     * format is 3 x N where N is the number of points.
     * @param x2 the image 2 set of correspondence points in image reference frame.  
     * format is 3 x N where N is the number of points.
     * @return 
     * @throws no.uib.cipr.matrix.NotConvergedException 
     */
    public static ReconstructionResults calculateUsingEssentialMatrix(
        double[][] k1, double[][] k2,
        double[][] x1, double[][] x2) throws NotConvergedException {
                
<span class="pc bpc" id="L808" title="2 of 4 branches missed.">        if (x1.length != 3 || x2.length != 3) {</span>
<span class="nc" id="L809">            throw new IllegalArgumentException(&quot;x1.length must be 3 and so must x2.length&quot;);</span>
        }
<span class="fc" id="L811">        int n = x1[0].length;</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">        if (x2[0].length != n) {</span>
<span class="nc" id="L813">            throw new IllegalArgumentException(&quot;x1 and x2 must be same dimensions&quot;);</span>
        }
        
        /*
        http://www.cs.cmu.edu/~16385/s17/Slides/12.5_Reconstruction.pdf
        
        (1) compute fundamental mat5rix FM from the correspondence x1, x2
        (2) compute the camera matrices P1, P2 from FM.
        (3) For each point correspondence, compute the point X in 3D space (triangularization)
        */
        
<span class="fc" id="L824">        double[][] k1IntrInv = Camera.createIntrinsicCameraMatrixInverse(k1);</span>
<span class="fc" id="L825">        double[][] k2IntrInv = Camera.createIntrinsicCameraMatrixInverse(k2);</span>
        
        // the direction of the points is calculated by K^-1 * x
<span class="fc" id="L828">        double[][] x1Direction = MatrixUtil.multiply(k1IntrInv, x1);</span>
<span class="fc" id="L829">        double[][] x2Direction = MatrixUtil.multiply(k2IntrInv, x2);</span>
                
<span class="fc" id="L831">        DenseMatrix x1M = new DenseMatrix(x1Direction);</span>
<span class="fc" id="L832">        DenseMatrix x2M = new DenseMatrix(x2Direction);</span>
        
        // normalizing by unit standard to improve results of epipolar solution:
<span class="fc" id="L835">        EpipolarTransformer.NormalizedXY normXY1 </span>
<span class="fc" id="L836">            = EpipolarTransformer.normalizeUsingUnitStandard(x1M);</span>
<span class="fc" id="L837">        EpipolarTransformer.NormalizedXY normXY2 </span>
<span class="fc" id="L838">            = EpipolarTransformer.normalizeUsingUnitStandard(x2M);</span>
        
<span class="fc" id="L840">        DenseMatrix leftM = normXY1.getXy();</span>
<span class="fc" id="L841">        DenseMatrix rightM = normXY2.getXy();</span>
        
<span class="fc" id="L843">        double tolerance = 3.84; //3.84 5.99 7.82        </span>
<span class="fc" id="L844">        boolean useToleranceAsStatFactor = true;</span>
<span class="fc" id="L845">        ErrorType errorType = ErrorType.SAMPSONS;</span>
<span class="fc" id="L846">        EpipolarTransformationFit fitR = null;</span>
<span class="fc" id="L847">        boolean reCalcIterations = true;</span>
        
        DenseMatrix normalizedE;
        
        /*EpipolarTransformer tr = new EpipolarTransformer();        
        normalizedE = tr.calculateEpipolarProjection(leftM, rightM);
        DenseMatrix vNFM = tr.validateSolution(normalizedFM, leftM, rightM);
        
        Distances distances = new Distances();
        if (useToleranceAsStatFactor) {
            fitR = distances.calculateError2(vNFM, leftM, rightM,
                    errorType, tolerance);
        } else {
            fitR = distances.calculateError(vNFM, leftM, rightM,
                    errorType, tolerance);
        }*/
        
        //if true, solves for the Essential Matrix, else solves
        //for the Fundamental Matrix.  The difference is in the diagonal used for
        //dimension reduction.
<span class="fc" id="L867">        boolean coordsAreInCameraRefFrame = true;</span>
        
<span class="fc" id="L869">        RANSACSolver solver = new RANSACSolver();</span>
<span class="fc" id="L870">        fitR = solver.calculateEpipolarProjection(</span>
            leftM, rightM, errorType, useToleranceAsStatFactor, tolerance,
                reCalcIterations, coordsAreInCameraRefFrame);
        
<span class="fc" id="L874">        System.out.println(&quot;RANSAC fit=&quot; + fitR.toString());</span>
        
<span class="fc" id="L876">        normalizedE = fitR.getFundamentalMatrix();</span>
        
        // this is now back in the reference frame of the x1Direction and x2Direction
<span class="fc" id="L879">        DenseMatrix essentialM = EpipolarTransformer.denormalizeTheFundamentalMatrix(</span>
<span class="fc" id="L880">            normalizedE, normXY1.getNormalizationMatrices(),</span>
<span class="fc" id="L881">            normXY2.getNormalizationMatrices());</span>
        
        //=========
<span class="fc" id="L884">        double[][] _essentialMatrix = MatrixUtil.convertToRowMajor(essentialM);</span>
        
<span class="fc" id="L886">        MatrixUtil.SVDProducts svdE = MatrixUtil.performSVD(_essentialMatrix);</span>
        
<span class="pc bpc" id="L888" title="5 of 6 branches missed.">        assert(svdE.u[0].length == 3 &amp;&amp; svdE.u.length == 3);</span>
        
<span class="fc" id="L890">        double detU = MatrixUtil.determinant(svdE.u);</span>
<span class="fc" id="L891">        double detV = MatrixUtil.determinant(svdE.vT);</span>
        
<span class="fc" id="L893">        System.out.printf(&quot;SVD.u=\n%s\n&quot;, FormatArray.toString(svdE.u, &quot;%.3e&quot;));</span>
<span class="fc" id="L894">        System.out.printf(&quot;SVD.s=\n%s\n&quot;, FormatArray.toString(svdE.s, &quot;%.3e&quot;));</span>
<span class="fc" id="L895">        System.out.printf(&quot;SVD.vT=\n%s\n&quot;, FormatArray.toString(svdE.vT, &quot;%.3e&quot;));</span>
<span class="fc" id="L896">        System.out.printf(&quot;det(SVD.u)=%.2f\n&quot;, detU);</span>
<span class="fc" id="L897">        System.out.printf(&quot;det(SVD.vT)=%.2f\n&quot;, detV);</span>
        
        /*
        Szeliski 2010 chap 7:
        Once an estimate for the essential matrix E has been recovered, 
        the direction of the translation vector t can be estimated. 
        
        Note that the absolute distance between the two cameras can never 
        be recovered from pure image measurements alone without knowledge 
        about absolute camera and point positions or distances, often called ground 
        control points in photogrammetry.
        */
        
        // det(R)=1 is a proper rotation matrix.  rotation angles are counterclockwise.
        //           it's a special orthogonal matrix and provides the
        //           defining matrix representation of the group of proper n-dimensional rotations, denoted
        //           by SO(n). http://scipp.ucsc.edu/~haber/ph251/rotreflect_17.pdf
        // det(R)=-1 is an improper rotation matrix representing rotations that
        //           require mirrors.
        //           The most general improper rotation matrix is a product of a proper rotation by an
        //           angle θ about some axis nˆ and a mirror reflection through a plane that passes through
        //           the origin and is perpendicular to nˆ.  NOTE: nˆ is determined by
        //           the right hand rule.
        
        /*
        Sect 7.2 of Szeliski 2010 eqn (7.25) introduces
        R3 and R4 constructed from -U as 2 more rotation possibilities to be tested
        and that is necessary in some cases where det(R) would otherwise be -1
        (reflection).
        ...we only know both E and tˆup to a sign. Furthermore, the matrices U and V
        are not guaranteed to be rotations (you can flip both their signs and 
        still get a valid SVD).   
        For this reason, we have to generate all four possible rotation matrices
        
        R = +-U * R_Z(+-90)^T * V^T
           and keep the 2 whose determinant = 1
        */
<span class="fc" id="L934">        double[][] r1 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L935">        double[][] r2 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L936">        double[][] u = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L937">        populateWithDet1Rs(svdE, r1, r2, u);</span>
        
        // last column in u is the second epipole and is the direction of vector t
<span class="fc" id="L940">        double[] t1 = MatrixUtil.extractColumn(u, 2);</span>
<span class="fc" id="L941">        double[] t2 = Arrays.copyOf(t1, t1.length);</span>
<span class="fc" id="L942">        MatrixUtil.multiply(t2, -1); </span>
        
<span class="fc" id="L944">        System.out.printf(&quot;R1=\n%s\n&quot;, FormatArray.toString(r1, &quot;%.3e&quot;));</span>
<span class="fc" id="L945">        System.out.printf(&quot;R2=\n%s\n&quot;, FormatArray.toString(r2, &quot;%.3e&quot;));</span>
<span class="fc" id="L946">        System.out.printf(&quot;t1=\n%s\n&quot;, FormatArray.toString(t1, &quot;%.3e&quot;));</span>
<span class="fc" id="L947">        System.out.printf(&quot;t2=\n%s\n&quot;, FormatArray.toString(t2, &quot;%.3e&quot;));</span>
        
        //then of the 4 possible choices find the one with largest number of positive Z.
          
        //NOTE: the last column vector in u is the smallest
        //    eigenvector.  it is epipole2, that is, the right image position 
        //    of the epipolar projection of the left camera center.
        //    it's int the left null space of E.
                        
<span class="fc" id="L956">        x1M = extractIndices(new DenseMatrix(x1Direction), fitR.inlierIndexes);</span>
<span class="fc" id="L957">        x2M = extractIndices(new DenseMatrix(x2Direction), fitR.inlierIndexes);</span>
<span class="fc" id="L958">        x1 = MatrixUtil.convertToRowMajor(x1M);</span>
<span class="fc" id="L959">        x2 = MatrixUtil.convertToRowMajor(x2M);</span>
        
<span class="fc" id="L961">        double[][] rSelected = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L962">        double[] tSelected = new double[3];</span>
<span class="fc" id="L963">        double[][] XW = MatrixUtil.zeros(4, x1[0].length);</span>
<span class="fc" id="L964">        bestInCheiralityTest(x1, x2, k1, k2, r1, r2, t1, t2, rSelected, tSelected, XW);  </span>
        
<span class="fc" id="L966">        ReconstructionResults rr = new ReconstructionResults();</span>
<span class="fc" id="L967">        rr.XW = XW;</span>
<span class="fc" id="L968">        rr.k1ExtrRot = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L969">        rr.k1ExtrTrans = new double[]{0, 0, 0};</span>
<span class="fc" id="L970">        rr.k1Intr = k1;</span>
<span class="fc" id="L971">        rr.k2ExtrRot = rSelected;</span>
<span class="fc" id="L972">        rr.k2ExtrTrans = tSelected;</span>
<span class="fc" id="L973">        rr.k2Intr = k2;</span>
<span class="fc" id="L974">        rr.essentialMatrix = _essentialMatrix;</span>
<span class="fc" id="L975">        rr.svd = svdE;</span>
<span class="fc" id="L976">        rr.fundamentalMatrix = null;</span>

<span class="fc" id="L978">        return rr;        </span>
    }

    /**
     * NOTE: not ready for use yet.
     * 
     * TODO: proof read the algorithm and write test for this.
     * for the case where the cameras are viewing small, distant scenes,
     * recover the 3-D coordinates in WCS and the rotation matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * assumes an orthographic camera model.
     * can use the orthographic camera model when
     *    (the average distance of an object from the camera) 
     *     .geq. 10*(the average width of the object (measured along the optical axis of the camera).
     * &lt;pre&gt;
     * references:
     * 
     * lecture 16 notes from Serge Belongie lectures from Computer Vision II, CSE 252B, USSD
     * http://www-cse.ucsd.edu/classes/sp04/cse252b/notes/lec16/lec16.pdf
     * 
     * lectures of Deva Ramanan at http://16720.courses.cs.cmu.edu/lec/sfm.pdf
     * .:w
     * 
     * Tomasi &amp; Kanade 1991, &quot;Shape and motion from image streams under 
     * orthography: a factorization method&quot;, International journal of computer vision 
     * 
     *  Morita and Kanade 1997 for solving Q.
         T. Morita and T. Kanade, A Sequential Factorization Method for Recovering Shape and Motion
         from Image Streams, Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 19,
         no.8, pp.858-867, Aug 1997  (1994?)
         
     * Higham, 1988, “Computing a Nearest Symmetric Positive Semidefinite Matrix,” 
     *    Linear Algebra and Appl., 103:103-118, 1988
     * 
     * a great summary of the above:
     * http://note.sonots.com/SciSoftware/Factorization.html#cse252b
     * http://note.sonots.com/?plugin=attach&amp;refer=SciSoftware%2FFactorization&amp;openfile=Factorization.pdf
     * 
     * and a derivation of the geometry of the tracking equation:
     * Birchfield 1997, &quot;Derivation of Kanade-Lucas-Tomasi Tracking Equation&quot;
     * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.185.413&amp;rep=rep1&amp;type=pdf
     * &lt;/pre&gt;
     * NOTE: could overload this method to enable handling of occlusion 
     * following Section 5 of Tomasi &amp; Kanade 1991, but might want to alter the
     * algorithm to use geometric median in place of centroid so that the
     * &quot;centers&quot; are not as affected by removing or adding a point.
     * NOTE: comments from Poelman &amp; Kanade 1992:
     * Orthographic projection does not account for the apparent change in size 
     * of an object as it moves toward or away from the camera, nor the different 
     * angle from which an object is viewed as it moves parallel to the image plane.
     * NOTE: consider implementing Section 3.3 Sequential Factorization Algorithm
     * from the Morita &amp; Kanade 1997 paper (1994?)
     * @param x the image coordinates of feature correspondences in 2 or more
     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates
     * and row 1 holds the y-coordinates and each image's features are given
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static OrthographicProjectionResults calculateAffineReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                                
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L1045">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1048">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="fc" id="L1050">        int nFeatures = x[0].length / mImages;</span>
        
        //2mn &gt;= 8m + 3n – 12
<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L1054">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12.&quot;
                +  &quot;\narguments: mImages=&quot; + mImages + &quot; nFeatures=&quot; + nFeatures
                + &quot;\n&quot; + (2*mImages * nFeatures) + &quot; &lt; &quot; +
                    (8*mImages +3*nFeatures - 12));
        }
        // for mImages=2, need 4 features
        
        // Tomasi &amp; Kanade 1992: An image stream can be represented by the
        //  2*F X P measurment matrix W of image coordinates of P points
        // tracked through F frames.
        
        // create matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size is mImages X nFeatures).
        //     where V is rows of each image's y coordinates (size is mImages X nFeatures).
        // create matrix t which holds the centroids of each row of W
        // create matrix WC = W - t
        
        // row[0] = image_0_x[0], image_0_x[1], image_0_x[2], ...
        // row[1] = image_1_x[0], image_1_x[1], image_1_x[2], ...
        // ...
        // row[mImages+0] = image_0_y[0], image_0_y[1], image_0_y[2], ...
<span class="fc" id="L1076">        double[][] w = MatrixUtil.zeros(2*mImages, nFeatures);</span>
        // t points to the camera's focal point
<span class="fc" id="L1078">        double[] t = new double[2*mImages];</span>
        int i, j;
        int m, n, rowU, rowV, col;
<span class="fc bfc" id="L1081" title="All 2 branches covered.">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="fc" id="L1082">            rowU = m;</span>
<span class="fc" id="L1083">            rowV = mImages + m;</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="fc" id="L1085">                col = nFeatures*m + n;</span>
<span class="fc" id="L1086">                w[rowU][n] = x[0][col];</span>
<span class="fc" id="L1087">                t[rowU] += x[0][col];</span>
<span class="fc" id="L1088">                w[rowV][n] = x[1][col];</span>
<span class="fc" id="L1089">                t[rowV] += x[1][col];</span>
            }
<span class="fc" id="L1091">            t[rowU] /= (double)nFeatures;</span>
<span class="fc" id="L1092">            t[rowV] /= (double)nFeatures;</span>
        }
        
        //registered measurement matrix:
<span class="fc" id="L1096">        double[][] wC = MatrixUtil.copy(w);</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">        for (i = 0; i &lt; t.length; ++i) {</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">            for (n = 0; n &lt; wC[i].length; ++n) {</span>
<span class="fc" id="L1099">                wC[i][n] -= t[i];</span>
            }
        }
        
        // see Fig 3.1 of Tomasi &amp; Kanade 1991 or Fig 2. of Belongie lecture notes
        
        // under orthography, this coordinate centered matrix has rank 3
        // and can be factored into the product of 2 matrices, R and S:
        // the camera rotation matrix R (size 2FX3) and 
        // the shape matrix S (size 3XP) which is shape in a coordinate system 
        // attached to the object centroid.
        //The two components of the camera translation along the image plane
        // are computed as averages of the rows of W
                
        // the registered measurement matrix is highly rank deficient
        // eqn (3.11)
<span class="fc" id="L1115">        SVDProducts svd = MatrixUtil.performSVD(wC);</span>
        
        // Tomasi &amp; Kanade 1992,eqn (3.12): 1st 3 columns of U, upper 3X3 of S, and first 3 rows of V^T
        //U3 is 2FX3 where F is the number of image frames
        //S3 is 3X3
        //VT3 is 3XP where P is the number of points, that is features, per image
<span class="fc" id="L1121">        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);</span>
<span class="fc" id="L1122">        double[][] s3 = MatrixUtil.zeros(3, 3);</span>
<span class="fc" id="L1123">        s3[0][0] = svd.s[0];</span>
<span class="fc" id="L1124">        s3[1][1] = svd.s[1];</span>
<span class="fc" id="L1125">        s3[2][2] = svd.s[2];</span>
<span class="fc" id="L1126">        double[][] sqrts3 = MatrixUtil.copy(s3);</span>
<span class="fc" id="L1127">        sqrts3[0][0] = Math.sqrt(sqrts3[0][0]);</span>
<span class="fc" id="L1128">        sqrts3[1][1] = Math.sqrt(sqrts3[1][1]);</span>
<span class="fc" id="L1129">        sqrts3[2][2] = Math.sqrt(sqrts3[2][2]);</span>
<span class="fc" id="L1130">        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);</span>
        
        // if the ratio between the 3rd and 4th largest singular value of the registered measurement matrix
        //   is large, then the noise portion of the full decomposition
        //   can be ignored (the noise portion is the block partitions not 
        //   copied to U3, sqrtS3 and vT3).
        // there is more about this in Morita &amp; Kanade 1994/1997
<span class="fc" id="L1137">        double sRatio = svd.s[2]/svd.s[3];</span>
<span class="fc" id="L1138">        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);</span>
        
        //Tamasi &amp; Kanade
        // (2*mImages)X3
<span class="fc" id="L1142">        double[][] rC = MatrixUtil.multiply(u3, sqrts3);</span>
        // 3XnFeatures
<span class="fc" id="L1144">        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);</span>
        
<span class="fc" id="L1146">        System.out.printf(&quot;rC=\n%s\n&quot;, FormatArray.toString(rC, &quot;%.4e&quot;));</span>
        
<span class="fc" id="L1148">        System.out.printf(&quot;wC=\n%s\n&quot;, FormatArray.toString(wC, &quot;%.4e&quot;));</span>
<span class="fc" id="L1149">        System.out.printf(&quot;rC*sC=\n%s\n&quot;, FormatArray.toString(</span>
<span class="fc" id="L1150">            MatrixUtil.multiply(rC, sC), </span>
            &quot;%.4e&quot;));
        
        // wC = rC * sC  
        //rC and sC are linear translations of the true rotation matrix R and
        //  the true shape matrix S, respectively.
        // Morita and Kanade: the decomposition is not completely unique.  
        //     it's unique only up to an affine transformation
        
        //Tomasi &amp; Kanade eqn (3.15) and Belongie Section 16.4.4 (c)
        // metric constraints:  
        // note that R is composed of rows of unit vectors.
        // note that the first F rows in R are orthogonal to the last F rows in R.
        
        /*
        NOTE: can make a rotation matrix orthonormal:
        svd = MatrixUtil.performSVD(rotationMAtrix);
        ortho = MatrixUtil.multiply(svd.u, MatrixUtil.transpose(svd.vT));
        detR = MatrixUtil.determinant(ortho);
        assert(Math.abs(detR - 1.)&lt;1.e-7);

        if no translation, can use procrustes to get difference in rotation:
           double[][] ar = Rotation.procrustesAlgorithmForRotation(rot1, _r2);
        */
        
        /*
        The rows of R represent the orientations of the horizontal and vertical camera
        reference axes throughout the stream, 
        while the columns of S are the coordinates of the P feature
        points with respect to their centroid.
        
        rC = [ i_hat_0[0] i_hat_0[2] i_hat_0[2] ] where i_hat_f are unit vectors
             [ i_hat_1[0] i_hat_1[2] i_hat_1[2] ]
             [   ..._m-1 ...                    ]
             [ j_hat_0[0] j_hat_0[2] j_hat_0[2] ]
             [ j_hat_1[0] j_hat_1[2] j_hat_1[2] ] where j_hat_f are unit vectors
             [  ..._m-1 ... ]
        
        sC = [s_C_1  ...  s_C_m] is [3XP] where P is the number of points per image frame
        NOTE that the summation over columns of sC = 0 (they are centered w.r.t. image points)
        
        R = rC*Q
        S = (Q^-1)*sC
        
          eqn (1)  (`i_f)^T * Q * Q^T * (`i_f) = 1   [dimensions 1X3 * 3X3 * 3X1 = 1]
          eqn (2)  (`j_f)^T * Q * Q^T * (`j_f) = 1
          eqn (3)  (`i_f)^T * Q * Q^T * (`j_f) = 0
        
        find Q as a 3 × 3 matrix, non-singular matrix
        
        //Morita and Kanade
        L = Q^T * Q
        solve the linear system of equations for L 
            and use Cholesky decomposition to get Q.
            Correct the decomposition to enforce L to be positive definite
            symmetric.
        
        See notes reference Morita and Kanade for solving Q.
         T. Morita and T. Kanade, A Sequential Factorization Method for Recovering Shape and Motion
         from Image Streams, Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 19,
         no.8, pp.858-867, Aug 1997  (1994?)
        
        http://note.sonots.com/SciSoftware/Factorization.html#cse252b
        
        L = [ l1 l2 l3 ]
            [ l2 l4 l5 ]
            [ l3 l5 l6 ]     

        the knowns are `i_f and `j_f, so we are solving for the 6 unknowns in L.

        expand the terms:

        eqn(1):
        if_0  if_1  if_2 ] * [ l1 l2 l3 ] * [ if_0 ] = 1
                             [ l2 l4 l5 ]   [ if_1 ]
                             [ l3 l5 l6 ]   [ if_2 ]
        eqn(2):
        jf_0  jf_1  jf_2 ] * [ l1 l2 l3 ] * [ jf_0 ] = 1
                             [ l2 l4 l5 ]   [ jf_1 ]
                             [ l3 l5 l6 ]   [ jf_2 ]
        eqn(3):
        if_0  if_1  if_2 ] * [ l1 l2 l3 ] * [ jf_0 ] = 0
                             [ l2 l4 l5 ]   [ jf_1 ]
                             [ l3 l5 l6 ]   [ jf_2 ]
        
        factor out the L terms, linearly
        l1           l2                    l3                    l4           l5                    l6         const
        (if0*if0)    (if1*if0 + if0*if1)   (if2*if0 + if0*if2)   (if1*if1)    (if2*if1 + if1*if2)   (if2*if2)   1
        (jf0*jf0)    (jf1*jf0 + jf0*jf1)   (jf2*jf0 + jf0*jf2)   (jf1*jf1)    (jf2*jf1 + jf1*jf2)   (jf2*jf2)   1
        (if0*jf0)    (if1*jf0 + if0*jf1)   (if2*jf0 + if0*jf2)   (if1*jf1)    (if2*jf1 + if1*jf2)   (if2*jf2)   0

        since the terms in the rows have a similar pattern, can write the equation more concisely using
        a function to generate them:
           g(a,b) = [a0*b0         ]
                    [a0*b1 + a1*b0 ]
                    [a0*b2 + a2*b0 ]
                    [a1*b1         ]
                    [a1*b2 + a2*b1 ]
                    [a2*b2         ]

        G size is 3*F X 6
        L is a vector of length 6
        c size is 3*F
        
        the G = [ g(i_0, i_0)^T       ]   L_vectorized = [l1]    c = [2*F rows of 1]
                [ ...each row thru F  ]                  [l2]        [F rows of 0  ]
                [ g(j_0, j_0)^T       ]                  [l3]
                [ ...each row thru F  ]                  [l4]
                [ g(i_0, j_0)^T       ]                  [l5]
                [ ...each row thru F  ]                  [l6]

        G*L_vectorized = c ==&gt;  L_vectorized = G^-1 * c
        */
        
<span class="fc" id="L1264">        double[] c = new double[3*mImages];</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        for (i = 0; i &lt; 2*mImages; ++i) {</span>
<span class="fc" id="L1266">            c[i] = 1;</span>
        }
        
        //g is 3F X 6
<span class="fc" id="L1270">        double[][] g = new double[3*mImages][6];</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">        for (i = 0; i &lt; 2*mImages; ++i) {</span>
<span class="fc" id="L1272">            g[i] = gT(rC[i], rC[i]);</span>
<span class="pc bpc" id="L1273" title="3 of 4 branches missed.">            assert(g[i].length == 6);</span>
        }
<span class="fc bfc" id="L1275" title="All 2 branches covered.">        for (i = 2*mImages, j=0; i &lt; 3*mImages; ++i, j++) {</span>
<span class="fc" id="L1276">            g[i] = gT(rC[mImages + j], rC[j]);</span>
        }
                
        // rank of G is 4
        //G * L = c
        // G^T * G * L = G^T * c
        // L = (G^T*G)^-1*G^T * c
        //     pseudoinverse of G is (G^T*G)^-1*G^T
<span class="fc" id="L1284">        double[][] gInv = MatrixUtil.pseudoinverseRankDeficient(g);</span>
        
        // 6X1
<span class="fc" id="L1287">        double[] lVector = MatrixUtil.multiplyMatrixByColumnVector(gInv, c);</span>
<span class="pc bpc" id="L1288" title="3 of 4 branches missed.">        assert(lVector.length == 6);</span>
        
        // 3X3
<span class="fc" id="L1291">        double[][] ell = new double[3][3];</span>
<span class="fc" id="L1292">        ell[0] = new double[]{lVector[0], lVector[1], lVector[2]};</span>
<span class="fc" id="L1293">        ell[1] = new double[]{lVector[1], lVector[3], lVector[4]};</span>
<span class="fc" id="L1294">        ell[2] = new double[]{lVector[2], lVector[4], lVector[5]};</span>
        
        // Q can be determined :
        //   as the square root of ell,
        //   or with the Cholesky decomposition
        //   or with eigendecomposition
        
        // enforcing positive definiteness of L (which is ell here).
<span class="fc" id="L1302">        double eps = 1e-17;//1.e-11; eps close to zero within machine precision to perturb the matrix to smallest eigenvalue of eps</span>
<span class="fc" id="L1303">        double[][] lPSD = MatrixUtil.nearestPositiveSemidefiniteToASymmetric(ell, eps);</span>
        /*EVD evd2 = EVD.factorize(new DenseMatrix(lPSD));
        double[] eig = evd2.getRealEigenvalues();
        double[][] aMinusPSD = MatrixUtil.elementwiseSubtract(ell, lPSD);
        double dist1 = MatrixUtil.frobeniusNorm(aMinusPSD);
        */
<span class="fc" id="L1309">        boolean ipd = MatrixUtil.isPositiveDefinite(lPSD);</span>
<span class="pc bpc" id="L1310" title="3 of 4 branches missed.">        assert(ipd);</span>
       
        //decompose Q = L * (sigma+) * L^T;  Q is size 3X3
<span class="fc" id="L1313">        double[][] q = LinearEquations.choleskyDecompositionViaMTJ(lPSD);</span>
        
        //Q is an affine transformation which transforms rC into R in motion space
        //   and the inverse of Q transforms sC into S in the shape space
        
        // finding Q is called &quot;Metric Transformation&quot;
        
        // rC size is  (2*mImages)X3
        // sC size is 3XnFeatures
<span class="fc" id="L1322">        double[][] r2 = MatrixUtil.multiply(rC, q);</span>
<span class="fc" id="L1323">        double[][] s2 = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q), sC);</span>
        
        // assert that wC is the same as wC2
<span class="fc" id="L1326">        System.out.printf(&quot;r2*s2=\n%s\n&quot;, FormatArray.toString(MatrixUtil.multiply(r2, s2), </span>
            &quot;%.4e&quot;));
        
        /*
        from Tomasi &amp; Kanade 1992:
        If desired, align the first camera reference system with the world 
        reference system by forming the products R*R_0 and R_0^T*S, 
        where the orthonormal matrix R_0 = [i1 j1 k1] rotates the first camera 
        reference system into the identity matrix
        
        i0x i0y i0z    *  r0ix  r0jx  r0kx   = (i0 dot r0i)  (i0 dot r0j) (i0 dot r0k)
        i1x i1y i1z       r0iy  r0jy  r0ky
        i2x i2y i2z       r0iz  r0jz  r0kz
        i3x i3y i3z
        ...
        j0x j0y j0z
        j1x j1y j1z
        */
        
<span class="fc" id="L1345">        System.out.printf(&quot;r2=\n%s\n&quot;, FormatArray.toString(r2, &quot;%.4e&quot;));</span>
 
        /* r2 * R0 = I
                R0 = inv(r2)
        */
<span class="fc" id="L1350">        double[][] rFirst = new double[3][3];</span>
<span class="fc" id="L1351">        rFirst[0] = Arrays.copyOf(r2[0], r2[0].length);</span>
<span class="fc" id="L1352">        rFirst[1] = Arrays.copyOf(r2[mImages], r2[mImages].length);</span>
<span class="fc" id="L1353">        rFirst[2] = MatrixUtil.crossProduct(rFirst[0], rFirst[1]);</span>
<span class="fc" id="L1354">        double[][] r0 = MatrixUtil.pseudoinverseFullColumnRank(rFirst);</span>
        
<span class="fc" id="L1356">        System.out.printf(&quot;chk==1: \n%s\n&quot;, FormatArray.toString(</span>
<span class="fc" id="L1357">            MatrixUtil.multiply(rFirst, r0),&quot;%.4e&quot;));</span>
        
        // with orthographic, can only recover rotation, not translation
        //(2*mImages)X3
        //apply to indiv rotation matrices
         
        // r has the i and j direction and k=i cross j.
        // create a stack of rotation matrices, one per image.
<span class="fc" id="L1365">        double[][] rotStack = MatrixUtil.zeros(3*mImages, 3);</span>
<span class="fc" id="L1366">        double[][] r3 = new double[2*mImages][];//(2*mImages)X3</span>
<span class="fc" id="L1367">        double[][] rTmp = new double[3][];</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="fc" id="L1369">            rTmp[0] = Arrays.copyOf(r2[i], r2[i].length);</span>
<span class="fc" id="L1370">            rTmp[1] = Arrays.copyOf(r2[mImages + i], r2[mImages + i].length);</span>
<span class="fc" id="L1371">            rTmp[2] = MatrixUtil.crossProduct(rTmp[0], rTmp[1]);</span>
<span class="fc" id="L1372">            rTmp = MatrixUtil.multiply(rTmp, r0);</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L1374">                rotStack[i*3 + j] = rTmp[j]; </span>
            }
<span class="fc" id="L1376">            r3[i] = rTmp[0];</span>
<span class="fc" id="L1377">            r3[i + mImages] = rTmp[1];</span>
        }
        
<span class="fc" id="L1380">        double[][] shape = MatrixUtil.multiply(rFirst, s2);</span>
        
<span class="fc" id="L1382">        System.out.printf(&quot;**r3=\n%s\n&quot;, FormatArray.toString(r3, </span>
            &quot;%.4e&quot;));
<span class="fc" id="L1384">        System.out.printf(&quot;**rot stack=\n%s\n&quot;, FormatArray.toString(rotStack, </span>
            &quot;%.4e&quot;));
        
<span class="fc" id="L1387">        System.out.printf(&quot;shape=\n%s\n&quot;, FormatArray.toString(shape, </span>
            &quot;%.4e&quot;));
        
<span class="fc" id="L1390">        System.out.printf(&quot;t=\n%s\n&quot;, FormatArray.toString(t, </span>
            &quot;%.4e&quot;));
        
        //assert eqn (3.7) of Tomasi &amp; Kanade:
        // original measurement matrix 
        //    W = R*X + t*(e_p)^T 
        //        where t = the vector of centroids a_0, a_1,...a_(F-1),b_0,b_1,...b_(F-1)
        //         and e_P^T is a vector of P 1's.
<span class="fc" id="L1398">        double[] ep = new double[nFeatures];</span>
<span class="fc" id="L1399">        Arrays.fill(ep, 1);</span>
<span class="fc" id="L1400">        double[][] tep = MatrixUtil.outerProduct(t, ep);</span>
<span class="fc" id="L1401">        System.out.printf(&quot;W = R*X + t*(e_p)^T=\n%s\n&quot;, </span>
<span class="fc" id="L1402">            FormatArray.toString(MatrixUtil.elementwiseAdd(</span>
<span class="fc" id="L1403">                MatrixUtil.multiply(r3, shape), tep), </span>
            &quot;%.4e&quot;));
<span class="fc" id="L1405">        System.out.printf(&quot;orig W = \n%s\n&quot;, FormatArray.toString(w, </span>
            &quot;%.4e&quot;));
        
<span class="fc" id="L1408">        OrthographicProjectionResults results = new OrthographicProjectionResults();</span>
<span class="fc" id="L1409">        results.XW = shape;</span>
<span class="fc" id="L1410">        results.rotationMatrices = rotStack;</span>
                
<span class="fc" id="L1412">        return results;</span>
    }
    
    /**
     * a look at enforcing orthonormal rotation
     * 
     * @param x
     * @param mImages
     * @return
     * @throws NotConvergedException 
     */
    static OrthographicProjectionResults _DoNotUseThisCalculateAffineReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
                                
<span class="nc bnc" id="L1426" title="All 2 branches missed.">        if (x.length != 2) {</span>
<span class="nc" id="L1427">            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);</span>
        }
<span class="nc bnc" id="L1429" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1430">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
        }
<span class="nc" id="L1432">        int nFeatures = x[0].length / mImages;</span>
        
        //2mn &gt;= 8m + 3n – 12
<span class="nc bnc" id="L1435" title="All 2 branches missed.">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L1436">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12.&quot;
                +  &quot;\narguments: mImages=&quot; + mImages + &quot; nFeatures=&quot; + nFeatures
                + &quot;\n&quot; + (2*mImages * nFeatures) + &quot; &lt; &quot; +
                    (8*mImages +3*nFeatures - 12));
        }
        // for mImages=2, need 4 features
        
        // Tomasi &amp; Kanade 1992: An image stream can be represented by the
        //  2*F X P measurment matrix W of image coordinates of P points
        // tracked through F frames.
        
        // create matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size is mImages X nFeatures).
        //     where V is rows of each image's y coordinates (size is mImages X nFeatures).
        // create matrix t which holds the centroids of each row of W
        // create matrix WC = W - t
        
        // row[0] = image_0_x[0], image_0_x[1], image_0_x[2], ...
        // row[1] = image_1_x[0], image_1_x[1], image_1_x[2], ...
        // ...
        // row[mImages+0] = image_0_y[0], image_0_y[1], image_0_y[2], ...
        //NOTE: adding the Z axis=1
<span class="nc" id="L1459">        double[][] w = MatrixUtil.zeros(3*mImages, nFeatures);</span>
<span class="nc" id="L1460">        double[] t = new double[3*mImages];</span>
        int i, j;
        int m, n, rowX, rowY, rowZ, col;
<span class="nc bnc" id="L1463" title="All 2 branches missed.">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="nc" id="L1464">            rowX = m;</span>
<span class="nc" id="L1465">            rowY = mImages + m;</span>
<span class="nc" id="L1466">            rowZ = 2*mImages + m;</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="nc" id="L1468">                col = nFeatures*m + n;</span>
<span class="nc" id="L1469">                w[rowX][n] = x[0][col];</span>
<span class="nc" id="L1470">                t[rowX] += x[0][col];</span>
<span class="nc" id="L1471">                w[rowY][n] = x[1][col];</span>
<span class="nc" id="L1472">                t[rowY] += x[1][col];</span>
<span class="nc" id="L1473">                w[rowZ][n] = 1;</span>
<span class="nc" id="L1474">                t[rowZ] += 1;</span>
            }
<span class="nc" id="L1476">            t[rowX] /= (double)nFeatures;</span>
<span class="nc" id="L1477">            t[rowY] /= (double)nFeatures;</span>
<span class="nc" id="L1478">            t[rowZ] /= (double)nFeatures;</span>
        }
        
        //registered measurement matrix:
<span class="nc" id="L1482">        double[][] wC = MatrixUtil.copy(w);</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        for (i = 0; i &lt; t.length; ++i) {</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            for (n = 0; n &lt; wC[i].length; ++n) {</span>
<span class="nc" id="L1485">                wC[i][n] -= t[i];</span>
            }
        }
        
        // see Fig 3.1 of Tomasi &amp; Kanade 1991 or Fig 2. of Belongie lecture notes
        
        // under orthography, this coordinate centered matrix has rank 3
        // and can be factored into the product of 2 matrices, R and S:
        // the camera rotation matrix R (size 2FX3) and 
        // the shape matrix S (size 3XP) which is shape in a coordinate system 
        // attached to the object centroid.
        //The two components of the camera translation along the image plane
        // are computed as averages of the rows of W
                
        // the registered measurement matrix is highly rank deficient
        // eqn (3.11)
<span class="nc" id="L1501">        SVDProducts svd = MatrixUtil.performSVD(wC);</span>
        
        // Tomasi &amp; Kanade 1992,eqn (3.12): 1st 3 columns of U, upper 3X3 of S, and first 3 rows of V^T
        //U3 is 2FX3 where F is the number of image frames
        //S3 is 3X3
        //VT3 is 3XP where P is the number of points, that is features, per image
<span class="nc" id="L1507">        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);</span>
<span class="nc" id="L1508">        double[][] s3 = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L1509">        s3[0][0] = svd.s[0];</span>
<span class="nc" id="L1510">        s3[1][1] = svd.s[1];</span>
<span class="nc" id="L1511">        s3[2][2] = svd.s[2];</span>
<span class="nc" id="L1512">        double[][] sqrts3 = MatrixUtil.copy(s3);</span>
<span class="nc" id="L1513">        sqrts3[0][0] = Math.sqrt(sqrts3[0][0]);</span>
<span class="nc" id="L1514">        sqrts3[1][1] = Math.sqrt(sqrts3[1][1]);</span>
<span class="nc" id="L1515">        sqrts3[2][2] = Math.sqrt(sqrts3[2][2]);</span>
<span class="nc" id="L1516">        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);</span>
        
        // if the ratio between the 3rd and 4th largest singular value of the registered measurement matrix
        //   is large, then the noise portion of the full decomposition
        //   can be ignored (the noise portion is the block partitions not 
        //   copied to U3, sqrtS3 and vT3).
        // there is more about this in Morita &amp; Kanade 1994/1997
<span class="nc" id="L1523">        double sRatio = svd.s[2]/svd.s[3];</span>
<span class="nc" id="L1524">        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);</span>
        
        //Tamasi &amp; Kanade
        // (2*mImages)X3
<span class="nc" id="L1528">        double[][] rC = MatrixUtil.multiply(u3, sqrts3);</span>
        // 3XnFeatures
<span class="nc" id="L1530">        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);</span>
        
<span class="nc" id="L1532">        System.out.printf(&quot;rC=\n%s\n&quot;, FormatArray.toString(rC, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L1534">        System.out.printf(&quot;w=\n%s\n&quot;, FormatArray.toString(w, &quot;%.4e&quot;));</span>
<span class="nc" id="L1535">        System.out.printf(&quot;wC=\n%s\n&quot;, FormatArray.toString(wC, &quot;%.4e&quot;));</span>
<span class="nc" id="L1536">        System.out.printf(&quot;rC*sC=\n%s\n&quot;, FormatArray.toString(</span>
<span class="nc" id="L1537">            MatrixUtil.multiply(rC, sC), </span>
            &quot;%.4e&quot;));
        
        // wC = rC * sC  
        //rC and sC are linear translations of the true rotation matrix R and
        //  the true shape matrix S, respectively.
        // Morita and Kanade: the decomposition is not completely unique.  
        //     it's unique only up to an affine transformation
        
        /*
        NLK: the rotation matrices aren't orthormal, so one needs to apply a linear
        transformation to rC that makes it orthonormal while applying the
        inverse transformation to sC to maintain the value of wC.
        
        wC = rC * sC

        let rC' be a single rotation matrix formed from the x-row of a frame in rC,
            the y-row of the same frame in rC, and the cross product of the x and y rows.
        rCO is obtained from SVD(rC').U*(SVD(rC').VT)^T)

        let R be the orthogonal rCO matrices reformatted into the x, y row format of rC
        
        since wC = R * Z * z^-1 * sC
              wC = R * Z^-1 * sC
              pseudoInv(R)*wC = pseudoInv(R)*R * Z^-1 * sC
              pseudoInv(R)*wC * pseudoInv(sC) = Z^-1 if inv(R)*R=I
               
              then can use Z^-1 to transform sC into s
        
        (3) Can continue with the rest of the Tomasi &amp; Kanade and Morita &amp; Kanade
            algorithm, eqn (3.15) below...
        */
        
        //sC is 3XnFeatures
        
        double[][] invR;
        
<span class="nc" id="L1574">        double[][] rot = new double[3*mImages][3];</span>
<span class="nc" id="L1575">        double[][] r3 = new double[2*mImages][3];</span>
<span class="nc" id="L1576">        double[][] shape = new double[3*mImages][nFeatures];</span>
        
        // 3X3
<span class="nc" id="L1579">        double[][] rCP = new double[3][];</span>
        double[] tmp;
        //3X3
        double[][] rCO;
        SVDProducts svdRC;
        double[][] si;
<span class="nc" id="L1585">        double[][] wCij = new double[3][];//3XnFeatures</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">        for (int ii = 0; ii &lt; mImages; ++ii) {</span>
<span class="nc" id="L1587">            rCP[0] = rC[ii];</span>
<span class="nc" id="L1588">            rCP[1] = rC[ii + mImages];</span>
<span class="nc" id="L1589">            rCP[2] = rC[ii + 2*mImages];</span>
<span class="nc" id="L1590">            tmp = MatrixUtil.crossProduct(rCP[0], rCP[1]);</span>
<span class="nc" id="L1591">            System.out.printf(&quot;compare %s to %s\n&quot;, </span>
<span class="nc" id="L1592">                FormatArray.toString(rCP[2], &quot;%.3e&quot;), FormatArray.toString(tmp, &quot;%.3e&quot;));</span>
    
<span class="nc" id="L1594">            System.out.printf(&quot;rC_%d=\n%s\n&quot;, ii, FormatArray.toString(rCP, &quot;%.4e&quot;));</span>
<span class="nc" id="L1595">            double detR = MatrixUtil.determinant(rCP);</span>
<span class="nc" id="L1596">            System.out.printf(&quot;det(rC_%d)=%.4e\n&quot;, ii, detR);</span>
            
<span class="nc" id="L1598">            svdRC = MatrixUtil.performSVD(rCP);</span>
<span class="nc" id="L1599">            rCO = MatrixUtil.multiply(svdRC.u, MatrixUtil.transpose(svdRC.vT));</span>
<span class="nc" id="L1600">            System.out.printf(&quot;r_uvtt=\n%s\n&quot;, FormatArray.toString(rCO, &quot;%.4e&quot;));</span>
<span class="nc" id="L1601">            detR = MatrixUtil.determinant(rCO);</span>
<span class="nc" id="L1602">            System.out.printf(&quot;det(r_uvtt_%d)=%.4e\n&quot;, ii, detR);</span>
           
<span class="nc" id="L1604">            System.out.printf(&quot;rC_%d * (rC_%d)^T=\n%s\n&quot;, ii, ii,</span>
<span class="nc" id="L1605">                FormatArray.toString(MatrixUtil.multiply(rCP, MatrixUtil.transpose(rCP)), &quot;%.4e&quot;));</span>
            
<span class="nc" id="L1607">            System.out.printf(&quot;r_uvtt_%d * (r_uvtt_%d)^T=\n%s\n&quot;, ii, ii,</span>
<span class="nc" id="L1608">                FormatArray.toString(MatrixUtil.multiply(rCO, MatrixUtil.transpose(rCO)), &quot;%.4e&quot;));</span>
            
<span class="nc" id="L1610">            System.out.flush();</span>
           
<span class="nc bnc" id="L1612" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L1613">                rot[ii*3 + j] = rCO[j];</span>
            }
<span class="nc" id="L1615">            r3[ii] = Arrays.copyOf(rCO[0], rCO[0].length);</span>
<span class="nc" id="L1616">            r3[ii + mImages] = Arrays.copyOf(rCO[1], rCO[1].length);</span>
            
            /*
            block[0] = rCP[0] times sC = 1XnFeatures
            block[1] = rCP[1] times sC
            block[2] = rCp[2] times sC 
            
            rC*z * (z^-1)*sC = 3X3*3X3*3XnFeatures = 3XnFeatures = block of wC
            rOrth * (z^-1)*sC= wC_i_j
            (z^-1)*sC= inv(rOth)*wC_i_j
            store in blocks of trans
            */     
<span class="nc" id="L1628">            invR = MatrixUtil.pseudoinverseFullColumnRank(rCO);</span>
            
            // 3XnFeatures
<span class="nc" id="L1631">            wCij[0] = wC[ii];</span>
<span class="nc" id="L1632">            wCij[1] = wC[ii + mImages];</span>
<span class="nc" id="L1633">            wCij[2] = wC[ii + 2*mImages];</span>
            
            //3XnFeatures
<span class="nc" id="L1636">            si = MatrixUtil.multiply(invR, wCij);</span>
            
            //double[][] trans = new double[3*mImages][nFeatures];
<span class="nc bnc" id="L1639" title="All 2 branches missed.">            for (j = 0; j &lt; 3; ++j) {</span>
<span class="nc" id="L1640">                shape[ii*3 + j] = si[j];</span>
            }
            
            // TODO: need to consider the rotation and translation origins now
<span class="nc" id="L1644">            System.out.printf(&quot;for image%d have shape=\n%s\n&quot;, ii, FormatArray.toString(si, &quot;%.4e&quot;));</span>
        }
        
<span class="nc" id="L1647">        System.out.printf(&quot;rot stack=\n%s\n&quot;, FormatArray.toString(rot, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L1650">        System.out.printf(&quot;shape=\n%s\n&quot;, FormatArray.toString(shape, </span>
            &quot;%.4e&quot;));
        
<span class="nc" id="L1653">        System.out.printf(&quot;t=\n%s\n&quot;, FormatArray.toString(t, </span>
            &quot;%.4e&quot;));
        // shape size is
        //r3 = new double[2*mImages][3];
<span class="nc" id="L1657">        double[][] _si = new double[3][nFeatures];</span>
<span class="nc" id="L1658">        double[][] _ri = new double[2][3];</span>
        double[][] _rs;
<span class="nc bnc" id="L1660" title="All 2 branches missed.">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L1661">            _si[0] = shape[i*mImages + i];//3XnFeatures</span>
<span class="nc" id="L1662">            _si[1] = shape[i*mImages + i + 1];</span>
<span class="nc" id="L1663">            _si[2] = shape[i*mImages + i + 2]; </span>
<span class="nc" id="L1664">            _ri[0] = r3[i*mImages + 0];//2X3</span>
<span class="nc" id="L1665">            _ri[1] = r3[i*mImages + 1];</span>
<span class="nc" id="L1666">            _rs = MatrixUtil.multiply(_ri, _si);//2XnFeatures</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">            for (int k = 0; k &lt; nFeatures; ++k) {</span>
<span class="nc" id="L1668">                _rs[0][k] += t[i*mImages + i];</span>
<span class="nc" id="L1669">                _rs[1][k] += t[i*mImages + i + 1];</span>
            }
            
<span class="nc" id="L1672">            System.out.printf(&quot;W = R*X + t*(e_p)^T=\n%s\n&quot;, </span>
<span class="nc" id="L1673">                FormatArray.toString(_rs, &quot;%.4e&quot;));</span>
        }
<span class="nc" id="L1675">        System.out.printf(&quot;original W = \n%s\n&quot;, </span>
<span class="nc" id="L1676">            FormatArray.toString(w, &quot;%.4e&quot;));</span>
        
<span class="nc" id="L1678">        OrthographicProjectionResults results = new OrthographicProjectionResults();</span>
<span class="nc" id="L1679">        results.XW = shape;</span>
<span class="nc" id="L1680">        results.rotationMatrices = rot;</span>
                
<span class="nc" id="L1682">        return results;</span>
           
    }
    
    /*
    TODO: proof read and write test for this.
    from Szeliski 2010 and Poelman &amp; Kanade 1992 (year?  a few published translations with different years):
    Para-perspective provides a more accurate projection model than scaled 
    orthography, without incurring the added complexity of per-pixel perspective 
    division, which invalidates traditional factoriza- tion methods 
    (Poelman and Kanade 1997).
    
    Scaled orthographic projection, sometimes referred to as &quot;weak perspective&quot;, 
    accounts for the scaling effect of an object as it moves towards and away 
    from the camera. Paraperspective projection, first introduced by Ohta in 
    [4] and named by Aloimonos in [1], accounts for the scaling effect as well 
    as the different angle from which an object is viewed as it moves in a 
    direction parallel to the image plane.

    */
    
    /**
     * for the case where the cameras are viewing small, distant scenes,
     * recover the 3-D coordinates in WCS and the projection matrices 
     * from pairs of corresponding
     * un-calibrated image points, that is, points in the image reference frame in pixels.
     * assumes a para-perspective camera model.
     *
     * Input set of P feature point coordinates (x_f_p,y_f_p) , for each of 
     * the F frames of the image sequence. From this information, our goal is 
     * to recover the estimated shape of the object, given by the position 
     * s_P, of every point, and the estimated motion of the
camera, given by |i, 3I, f• and i! for each frame in the sequence. Rather than recover if in world coordinates, we generally recover the threems.eparate components ], tf. jf, and
if'if.
 
      
     &lt;pre&gt;
      references:
      
     Poelman &amp; Kanade 1997 (1994), &quot;A Paraperspective Factorization Method for Shape 
     and Motion Recovery&quot; 
     
     Description from Poelman &amp; Kanade:
      
     Each feature point p that we track corresponds to a single world point, 
      located at position s. in some fixed world coordinate system.

      Each image f was taken at some specific camera orientation, which we 
      describe by the orthonormal unit vectors i_f, j_f and k_f 
      where kf_ points along the camera's line of sight, 
<span class="nc bnc" id="L1732" title="All 2 branches missed.">      i_f corresponds to the camera image plane's x-axis, </span>
<span class="nc" id="L1733">      and j_f corresponds to the camera image's y-axis.</span>
      
<span class="nc bnc" id="L1735" title="All 2 branches missed.">      t_f is a vector pointing from the origin of the fixed world coordinate system</span>
<span class="nc" id="L1736">      to the camera's focal plane.  it's the position of the camera in each fram f.</span>
      
<span class="nc" id="L1738">     &lt;/pre&gt;</span>
     * 
     * @param x the image coordinates of feature correspondences in 2 or more
<span class="nc bnc" id="L1741" title="All 2 branches missed.">     * images.  format is 2 X (nImages * nFeatures) where row 0 holds the x-coordinates</span>
<span class="nc" id="L1742">     * and row 1 holds the y-coordinates and each image's features are given</span>
     * before the next and the features are ordered in the same manner within
     * all images.
     * for example: row 0 = [img_0_feature_0, ... img_0_feature_n-1, ... img_m-1_feature_0,...
     *     img_m-1_feature_n-1].
     * @param mImages the number of images in x.
     * @return the estimated projections P1 and P2 and the objects locations as 3-D points;
     */
    public static ParaperspectiveProjectionResults calculateParaperspectiveReconstruction(
        double[][] x, int mImages) throws NotConvergedException {
<span class="nc" id="L1752">                        </span>
<span class="nc" id="L1753">        if (x.length != 2) {</span>
            throw new IllegalArgumentException(&quot;x.length must be 2&quot;);
        }
<span class="nc bnc" id="L1756" title="All 2 branches missed.">        if ((x[0].length % mImages) != 0) {</span>
<span class="nc" id="L1757">            throw new IllegalArgumentException(&quot;x must have a multiple of mImages as the number of columns&quot;);</span>
<span class="nc bnc" id="L1758" title="All 2 branches missed.">        }</span>
<span class="nc" id="L1759">        int nFeatures = x[0].length / mImages;</span>
<span class="nc" id="L1760">        </span>
<span class="nc" id="L1761">        //2mn &gt;= 8m + 3n – 12</span>
<span class="nc" id="L1762">        if ((2*mImages * nFeatures) &lt; (8*mImages +3*nFeatures - 12)) {</span>
<span class="nc" id="L1763">            throw new IllegalArgumentException(&quot;more points are necessary:&quot;</span>
                + &quot;2 * mImages * nFeatures &gt;= 8 * mImages + 3 * nFeatures – 12&quot;);
<span class="nc" id="L1765">        }</span>
<span class="nc" id="L1766">        // for mImages=2, need 4 features</span>
        
        // create matrix W composed of U and V 
        //     where U is rows of each image's x coordinates (size os mImages X nFeatures).
<span class="nc" id="L1770">        //     where V is rows of each image's y coordinates (size os mImages X nFeatures).</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">        // create matrix t which holds the centroids of each row of W</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">        // create matrix WC = W - t</span>
<span class="nc" id="L1773">        double[][] w = MatrixUtil.zeros(2*mImages, nFeatures);</span>
        double[] t = new double[2*mImages];
        int i, j;
        int m, n, xCol, vRow;
<span class="nc" id="L1777">        for (m = 0; m &lt; mImages; ++m) {</span>
<span class="nc" id="L1778">            vRow = mImages + m;</span>
<span class="nc" id="L1779">            for (n = 0; n &lt; nFeatures; ++n) {</span>
<span class="nc" id="L1780">                xCol = m * nFeatures + n;</span>
<span class="nc" id="L1781">                w[m][n] = x[0][xCol];</span>
<span class="nc" id="L1782">                t[m] += x[0][xCol];</span>
<span class="nc" id="L1783">                w[vRow][n] = x[1][xCol];</span>
<span class="nc" id="L1784">                t[vRow] += x[1][xCol];</span>
<span class="nc" id="L1785">            }</span>
<span class="nc" id="L1786">            t[m] /= (double)nFeatures;</span>
<span class="nc" id="L1787">            t[vRow] /= (double)nFeatures;</span>
        }
        
<span class="nc" id="L1790">        //registered measurement matrix:</span>
<span class="nc" id="L1791">        double[][] wC = MatrixUtil.copy(w);</span>
        for (i = 0; i &lt; t.length; ++i) {
            for (n = 0; n &lt; nFeatures; ++n) {
<span class="nc" id="L1794">                wC[i][n] -= t[i];</span>
            }
<span class="nc" id="L1796">        }</span>
        
        SVDProducts svd = MatrixUtil.performSVD(wC);
        double[][] u3 = MatrixUtil.copySubMatrix(svd.u, 0, svd.u.length-1, 0, 2);
        double[][] s3 = MatrixUtil.zeros(3, 3);
        s3[0][0] = svd.s[0];
        s3[1][1] = svd.s[1];
        s3[2][2] = svd.s[2];
        double[][] sqrts3 = MatrixUtil.zeros(3, 3);
        sqrts3[0][0] = Math.sqrt(svd.s[0]);
        sqrts3[1][1] = Math.sqrt(svd.s[1]);
        sqrts3[2][2] = Math.sqrt(svd.s[2]);
        double[][] vT3 = MatrixUtil.copySubMatrix(svd.vT, 0, 2, 0, svd.vT[0].length-1);
        
        // if this is large, then the noise contribution can be ignored (cholesky not necessary)
        double sRatio = svd.s[2]/svd.s[3];
        System.out.printf(&quot;svd.s[2]/svd.s[3]=%.3e\n&quot;, sRatio);
                
        // (2*mImages)X3
        double[][] mC = MatrixUtil.multiply(u3, sqrts3);
        // 3XnFeatures
        double[][] sC = MatrixUtil.multiply(sqrts3, vT3);
        
        /*
        ------------------------------------------------------------------
        Paraperspective Normalization
        ------------------------------------------------------------------
        
         3 constraints:

         eqn(15) of paper:
                 |m_f|^2/(1+x_f^2) - |n_f|^2/(1+y_f^2) = 0
         eqn(17) of paper:
                 m_f dot n_f = x_f * y*f * 0.5 * ( |m_f|^2/(1+x_f^2) + |n_f|^2/(1+y_f^2) )
         eqn(18) of paper:
                 |m_0|=1

         those are 2*F + 1 equations as metric constraints

         from the SVD of the registered measurement matrix, there is M and S
         `M is size 2*F X 3
         `M = vectorized( m_0, m_1, ... m_{F-1}, n_0, n_1, ... n_{F-1},

         let M = `M*A where A is a 3X3 matrix, and as before, Q = symmetric matrix, but Q=A^T*A.

         Equations (15), (17), and (18) give us 2F+ 1 equations,
         We compute the 3 X 3 matrix A such that M = `M*A best satisfies these metric constraints
         in the least sum-of-squares error sense.

         This is a simple problem because the constraints are linear in the 6 unique elements
         of the symmetric 3 x 3 matrix Q = A^TA.
        
         Thus we compute Q by solving the overconstrained linear system of 2F + 1 equations
         in 6 variables defined by the metric constraints, ...

             [ q1  q2  q3 ]
         Q = [ q2  q4  q5 ]
             [ q3  q5  q6 ]

         m_f = `m_f * Q = [`mf0  `mf1  `mf2] * [ q1  q2  q3 ]
                                               [ q2  q4  q5 ]
                                               [ q3  q5  q6 ]
                        = [ (q1*`mf0 + q2*`mf1 + q3*`mf2 )  (q2*`mf0 + q4*`mf1 + q5*`mf2 )  (q3*`mf0 + q5*`mf1 + q6*`mf2 ) ]

         |vector| is the magnitude of a vector = square root of the sum of squares of its components.
        
         as an aside, in case can simplify any future steps with this:
         and Q*Q = q1*q1 + q2*q2 + q3*q3   q1*q2 + q2*q4 + q3*q5   q1*q3 + q2*q5 + q3*q6
                   q1*q2 + q2*q4 + q3*q5   q2*q2 + q4*q4 + q5*q5   q2*q3 + q4*q5 + q5*q6
                   q1*q3 + q2*q5 + q3*q6   q2*q3 + q4*q5 + q5*q6   q3*q3 + q5*q5 + q6*q6
                 = Q_col0 dot Q_col0   Q_col0 dot Q_col1  Q_col0 dot Q_col2
                   Q_col0 dot Q_col1   Q_col1 dot Q_col1  Q_col1 dot Q_col2
                   Q_col0 dot Q_col2   Q_col1 dot Q_col2  Q_col2 dot Q_col2

        NOTE: below are the expanded details of the multiplication.
        The result can be rewritten using other notation:
        since need the dot product of vector `m_f*Q with itself, can use the inner product
        of the vector multiplied by its transpose:
            |m_f|^2 = `m_f*Q*Q^T*`m_f^T where m_f is a 1X3 vector and Q is a 3X3 symmetric matrix
                    = `m_f*Q^2*`m_f^T
                    = [`m_f*Q^2[:][0] `m_f*Q^2[:][1] `m_f*Q^2[:][2]] * `m_f^T
                    = ['m_f[0]*`m_f*Q^2[:][0] + 'm_f[1]*`m_f*Q^2[:][1] + 'm_f[2]*`m_f*Q^2[:][2]]


         expand |m_f|^2/(1+x_f^2) :
             (1/(1+x_f^2)) * [ (q1*`mf0 + q2*`mf1 + q3*`mf2 )^2 + (q2*`mf0 + q4*`mf1 + q5*`mf2 )^2 + (q3*`mf0 + q5*`mf1 + q6*`mf2 )^2 ]
             (1/(1+x_f^2)) * [ (q1*`mf0*q1*`mf0 + q1*`mf0*q2*`mf1 + q1*`mf0*q3*`mf2)
                              + (q2*`mf1*q1*`mf0 + q2*`mf1*q2*`mf1 + q2*`mf1*q3*`mf2)
                              + (q3*`mf2*q1*`mf0 + q3*`mf2*q2*`mf1 + q3*`mf2*q3*`mf2)
                              + (q2*`mf0*q2*`mf0 + q2*`mf0*q4*`mf1 + q2*`mf0*q5*`mf2 )
                              + (q4*`mf1*q2*`mf0 + q4*`mf1*q4*`mf1 + q4*`mf1*q5*`mf2 )
                              + (q5*`mf2*q2*`mf0 + q5*`mf2*q4*`mf1 + q5*`mf2*q5*`mf2 )
                              + (q3*`mf0*q3*`mf0 + q3*`mf0*q5*`mf1 + q3*`mf0*q6*`mf2 )
                              + (q5*`mf1*q3*`mf0 + q5*`mf1*q5*`mf1 + q5*`mf1*q6*`mf2 )
                              + (q6*`mf2*q3*`mf0 + q6*`mf2*q5*`mf1 + q6*`mf2*q6*`mf2 ) ]

             (1/(1+x_f^2))  * [ (q1*`mf0*q1*`mf0 + q1*`mf0*q2*`mf1 + q1*`mf0*q3*`mf2)
                              + (q1*`mf0*q2*`mf1 + q2*`mf1*q2*`mf1 + q2*`mf1*q3*`mf2)
                              + (q1*`mf0*q3*`mf2 + q2*`mf1*q3*`mf2 + q3*`mf2*q3*`mf2)
                              + (q2*`mf0*q2*`mf0 + q2*`mf0*q4*`mf1 + q2*`mf0*q5*`mf2 )
                              + (q2*`mf0*q4*`mf1 + q4*`mf1*q4*`mf1 + q4*`mf1*q5*`mf2 )
                              + (q2*`mf0*q5*`mf2 + q4*`mf1*q5*`mf2 + q5*`mf2*q5*`mf2 )
                              + (q3*`mf0*q3*`mf0 + q3*`mf0*q5*`mf1 + q3*`mf0*q6*`mf2 )
                              + (q3*`mf0*q5*`mf1 + q5*`mf1*q5*`mf1 + q5*`mf1*q6*`mf2 )
                              + (q3*`mf0*q6*`mf2 + q6*`mf2*q5*`mf1 + q6*`mf2*q6*`mf2 ) ]
        
                          (1/(1+x_f^2))  * [ q1*q1*`mf0*`mf0 + q1*q2*`mf0*`mf1 + q1*q3*`mf0*`mf2
                              + q1*q2*`mf0*`mf1 + q2*q2*`mf1*`mf1 + q2*q3*`mf1*`mf2
                              + q1*q3*`mf0*`mf2 + q2*q3*`mf1*`mf2 + q3*q3*`mf2*`mf2
                              + q2*q2*`mf0*`mf0 + q2*q4*`mf0*`mf1 + q2*q5*`mf0*`mf2
                              + q2*q4*`mf0*`mf1 + q4*q4*`mf1*`mf1 + q4*q5*`mf1*`mf2
                              + q2*q5*`mf0*`mf2 + q4*q5*`mf1*`mf2 + q5*q5*`mf2*`mf2
                              + q3*q3*`mf0*`mf0 + q3*q5*`mf0*`mf1 + q3*q6*`mf0*`mf2
                              + q3*q5*`mf0*`mf1 + q5*q5*`mf1*`mf1 + q5*q6*`mf1*`mf2
                              + q3*q6*`mf0*`mf2 + q6*q5*`mf2*`mf1 + q6*q6*`mf2*`mf2 ]

             (1/(1+x_f^2))  * [ q1*q1*`mf0*`mf0 + q2*q2*`mf0*`mf0 + q3*q3*`mf0*`mf0
                              + q1*q2*`mf0*`mf1 + q2*q4*`mf0*`mf1 + q3*q5*`mf0*`mf1   &lt;== 1st 3 lines of addition are:
                              + q1*q3*`mf0*`mf2 + q2*q5*`mf0*`mf2 + q3*q6*`mf0*`mf2       [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ] * [Q^2_col0]

                              + q1*q2*`mf0*`mf1 + q2*q4*`mf0*`mf1 + q3*q5*`mf0*`mf1   &lt;== 2nd 3 lines of addition are:
                              + q2*q2*`mf1*`mf1 + q4*q4*`mf1*`mf1 + q5*q5*`mf1*`mf1       [ `mf0*`mf1  `mf1*`mf1  `mf1*`mf2 ] * [Q^2_col1]
                              + q2*q3*`mf1*`mf2 + q4*q5*`mf1*`mf2 + q5*q6*`mf1*`mf2

                              + q1*q3*`mf0*`mf2 + q2*q5*`mf0*`mf2 + q3*q6*`mf0*`mf2   &lt;== 3rd 3 lines of addition are:
                              + q2*q3*`mf1*`mf2 + q4*q5*`mf1*`mf2 + q5*q6*`mf1*`mf2       [ `mf0*`mf2  `mf1*`mf2  `mf2*`mf2 ] * [Q^2_col2]
                              + q3*q3*`mf2*`mf2 + q5*q5*`mf2*`mf2 + q6*q6*`mf2*`mf2 ]

             let z0 = [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ]
                 z1 = [ `mf0*`mf1  `mf1*`mf1  `mf1*`mf2 ]
                 z2 = [ `mf0*`mf2  `mf1*`mf2  `mf2*`mf2 ]
             (1/(1+x_f^2))  * [ z0 z1 z2] * [Q^2_col0]
                                            [Q^2_col1]
                                            [Q^2_col2]

         reminder of Q*Q:
                 = q1*q1 + q2*q2 + q3*q3   q1*q2 + q2*q4 + q3*q5   q1*q3 + q2*q5 + q3*q6
                   q1*q2 + q2*q4 + q3*q5   q2*q2 + q4*q4 + q5*q5   q2*q3 + q4*q5 + q5*q6
                   q1*q3 + q2*q5 + q3*q6   q2*q3 + q4*q5 + q5*q6   q3*q3 + q5*q5 + q6*q6
                 = Q_col0 dot Q_col0   Q_col0 dot Q_col1  Q_col0 dot Q_col2
                   Q_col0 dot Q_col1   Q_col1 dot Q_col1  Q_col1 dot Q_col2
                   Q_col0 dot Q_col2   Q_col1 dot Q_col2  Q_col2 dot Q_col2
            
             let z0 = [ `mf0*`mf0  `mf0*`mf1  `mf0*`mf2 ]
                 z1 = [ `mf1*`mf0  `mf1*`mf1  `mf1*`mf2 ]
                 z2 = [ `mf2*`mf0  `mf2*`mf1  `mf2*`mf2 ]
             let y0 = [ `nf0*`nf0  `nf0*`nf1  `nf0*`nf2 ]
                 y1 = [ `nf1*`nf0  `nf1*`nf1  `nf1*`nf2 ]
                 y2 = [ `nf2*`nf0  `nf2*`nf1  `nf2*`nf2 ]
             let w0 = [ `mf0*`nf0  `mf0*`nf1  `mf0*`nf2 ]
                 w1 = [ `mf1*`nf0  `mf1*`nf1  `mf1*`nf2 ]
                 w2 = [ `mf2*`nf0  `mf2*`nf1  `mf2*`nf2 ]
             let c2 = (x_f*y_f*0.5)

        factoring the constraints to separate Q unknowns from m and n knowns:
         eqn(15) of paper:
                 |m_f|^2/(1+x_f^2) - |n_f|^2/(1+y_f^2) = 0

             (1/(1+x_f^2)) * [ z0 z1 z2] * [Q^2_col0]  -  (1/(1+y_f^2)) * [ y0 y1 y2] * [Q^2_col0] = 0
                                           [Q^2_col1]                                   [Q^2_col1]
                                           [Q^2_col2]                                   [Q^2_col2]

             [ (z0/(1+x_f^2) -y0/(1+y_f^2))  (z1/(1+x_f^2) -y1/(1+y_f^2))  (z2/(1+x_f^2) -y2/(1+y_f^2)) ] * [Q^2_col0] = 0
                                                                                                            [Q^2_col1]
                                                                                                            [Q^2_col2]

         eqn(17) of paper:
                 m_f dot n_f = x_f*y_f*0.5 * ( |m_f|^2/(1+x_f^2) + |n_f|^2/(1+y_f^2) )
<span class="nc" id="L1964"></span>
<span class="nc" id="L1965">                 [ w0 w1 w2] * [Q^2_col0] - c2 * [ z0 z1 z2] * [Q^2_col0]  -  c2 * [ y0 y1 y2] * [Q^2_col0] = 0</span>
<span class="nc" id="L1966">                               [Q^2_col1]                      [Q^2_col1]                        [Q^2_col1]</span>
<span class="nc" id="L1967">                               [Q^2_col2]                      [Q^2_col2]                        [Q^2_col2]</span>
<span class="nc" id="L1968"></span>
<span class="nc" id="L1969">                 [ (w0 -z0*c2 -y0*c2)  (w1 -z1*c2 -y1*c2)  (w2 -z2*c2 -y2*c2)] * [Q^2_col0] = 0</span>
<span class="nc" id="L1970">                                                                                 [Q^2_col1]</span>
<span class="nc" id="L1971">                                                                                 [Q^2_col2]</span>
<span class="nc" id="L1972">         eqn(18) of paper:</span>
<span class="nc" id="L1973">                 |m_0|=1</span>

                 square to use the same factorization by Q^2?
<span class="nc bnc" id="L1976" title="All 2 branches missed."></span>
<span class="nc" id="L1977">             let v0 = [ `m_0[0]*`mf0  `m_0[0]*`m_0[1]  `m_0[0]*`m_0[2] ]</span>
<span class="nc" id="L1978">                 v1 = [ `m_0[0]*`mf1  `m_0[1]*`m_0[1]  `m_0[1]*`m_0[2] ]</span>
                 v2 = [ `m_0[0]*`mf2  `m_0[1]*`m_0[2]  `m_0[2]*`m_0[2] ]
<span class="nc" id="L1980">             |m_0|^2 = [ v0 v1 v2] * [Q^2_col0] = 1</span>
<span class="nc" id="L1981">                                     [Q^2_col1]</span>
<span class="nc" id="L1982">                                     [Q^2_col2]</span>
        */
<span class="nc" id="L1984">        </span>
<span class="nc" id="L1985">        double[][] g = new double[2*mImages + 1][9];</span>
<span class="nc" id="L1986">        double[] z0 = new double[3];</span>
        double[] z1 = new double[3];
<span class="nc" id="L1988">        double[] z2 = new double[3];</span>
<span class="nc" id="L1989">        double[] y0 = new double[3];</span>
<span class="nc" id="L1990">        double[] y1 = new double[3];</span>
        double[] y2 = new double[3];
<span class="nc" id="L1992">        double[] w0 = new double[3];</span>
<span class="nc" id="L1993">        double[] w1 = new double[3];</span>
<span class="nc" id="L1994">        double[] w2 = new double[3];</span>
        double c2, xf, yf, divXf, divYf;
<span class="nc" id="L1996">        </span>
<span class="nc" id="L1997">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L1998">            xf = t[i];</span>
            yf = t[mImages + i];
<span class="nc" id="L2000">            </span>
<span class="nc" id="L2001">            z0[0] = mC[i][0] * mC[i][0]; </span>
<span class="nc" id="L2002">            z0[1] = mC[i][0] * mC[i][1];</span>
            z0[2] = mC[i][0] * mC[i][2];
<span class="nc" id="L2004">            </span>
<span class="nc" id="L2005">            z1[0] = mC[i][1] * mC[i][0]; </span>
<span class="nc" id="L2006">            z1[1] = mC[i][1] * mC[i][1];</span>
            z1[2] = mC[i][1] * mC[i][2];
<span class="nc" id="L2008">            </span>
<span class="nc" id="L2009">            z2[0] = mC[i][2] * mC[i][0]; </span>
<span class="nc" id="L2010">            z2[1] = mC[i][2] * mC[i][1];</span>
            z2[2] = mC[i][2] * mC[i][2];
<span class="nc" id="L2012">            </span>
<span class="nc" id="L2013">            y0[0] = mC[mImages + i][0] * mC[mImages + i][0];</span>
<span class="nc" id="L2014">            y0[1] = mC[mImages + i][0] * mC[mImages + i][1];</span>
            y0[2] = mC[mImages + i][0] * mC[mImages + i][2];
<span class="nc" id="L2016">            </span>
            y1[0] = mC[mImages + i][1] * mC[mImages + i][0];
<span class="nc" id="L2018">            y1[1] = mC[mImages + i][1] * mC[mImages + i][1];</span>
<span class="nc" id="L2019">            y1[2] = mC[mImages + i][1] * mC[mImages + i][2];</span>
            
            y2[0] = mC[mImages + i][2] * mC[mImages + i][0];
            y2[1] = mC[mImages + i][2] * mC[mImages + i][1];
            y2[2] = mC[mImages + i][2] * mC[mImages + i][2];
<span class="nc" id="L2024">            </span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">            w0[0] = mC[i][0] * mC[mImages + i][0];</span>
<span class="nc" id="L2026">            w0[1] = mC[i][0] * mC[mImages + i][1];</span>
<span class="nc" id="L2027">            w0[2] = mC[i][0] * mC[mImages + i][2];</span>
<span class="nc" id="L2028">            </span>
            w1[0] = mC[i][1] * mC[mImages + i][0];
            w1[1] = mC[i][1] * mC[mImages + i][1];
            w1[2] = mC[i][1] * mC[mImages + i][2];
            
<span class="nc" id="L2033">            w2[0] = mC[i][2] * mC[mImages + i][0];</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">            w2[1] = mC[i][2] * mC[mImages + i][1];</span>
<span class="nc" id="L2035">            w2[2] = mC[i][2] * mC[mImages + i][2];</span>
<span class="nc" id="L2036">            </span>
<span class="nc" id="L2037">            c2 = 0.5*xf*yf;</span>
            
            divXf = 1./(1.+xf*xf);
            divYf = 1./(1.+yf*yf);
            
            // length 9
            // eqn(15) of paper is the 1st mImages rows of g
            //   [ (z0/(1+x_f^2) -y0/(1+y_f^2))  (z1/(1+x_f^2) -y1/(1+y_f^2))  (z2/(1+x_f^2) -y2/(1+y_f^2)) ] ... = 0
            g[i] = new double[9]; // g is (2*mImages + 1) X 9;
<span class="nc" id="L2046">            for (j = 0; j &lt; 3; ++j) { </span>
<span class="nc" id="L2047">                g[i][j] = (z0[j]*divXf - y0[j]*divYf);                </span>
                g[i][3+j] = (z1[j]*divXf - y1[j]*divYf);
<span class="nc" id="L2049">                g[i][6+j] = (z2[j]*divXf - y2[j]*divYf);                </span>
            }
<span class="nc" id="L2051">            </span>
            //eqn(17) of paper is the 2nd mImages rows of g
<span class="nc" id="L2053">            //  [ (w0 -z0*c2 -y0*c2)  (w1 -z1*c2 -y1*c2)  (w2 -z2*c2 -y2*c2)] ... = 0</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">            g[mImages + i] = new double[9]; // g is (2*mImages + 1) X 9;</span>
<span class="nc" id="L2055">            for (j = 0; j &lt; 3; ++j) { </span>
<span class="nc" id="L2056">                g[mImages + i][j] = (w0[j] - z0[j]*c2 - y0[j]*c2);                </span>
<span class="nc" id="L2057">                g[mImages + i][3+j] = (w1[j] - z1[j]*c2 - y1[j]*c2);</span>
                g[mImages + i][6+j] = (w2[j] - z2[j]*c2 - y2[j]*c2);               
            }
<span class="nc" id="L2060">        }</span>
<span class="nc" id="L2061">        </span>
        //let v0 = [ `m_0[0]*`mf0  `m_0[0]*`m_0[1]  `m_0[0]*`m_0[2] ]
<span class="nc" id="L2063">        //    v1 = [ `m_0[0]*`mf1  `m_0[1]*`m_0[1]  `m_0[1]*`m_0[2] ]</span>
<span class="nc" id="L2064">        //    v2 = [ `m_0[0]*`mf2  `m_0[1]*`m_0[2]  `m_0[2]*`m_0[2] ]</span>
<span class="nc bnc" id="L2065" title="All 4 branches missed.">        // length 9</span>
        // [ v0 v1 v2 ] = 1
        i = 0;
<span class="nc" id="L2068">        double[] v0 = new double[] {</span>
<span class="nc" id="L2069">           mC[i][0] * mC[i][0], mC[i][0] * mC[i][1], mC[i][0] * mC[i][2]};</span>
<span class="nc" id="L2070">        double[] v1 = new double[] {</span>
<span class="nc" id="L2071">            mC[i][1] * mC[i][0], mC[i][1] * mC[i][1], mC[i][1] * mC[i][2]};</span>
        double[] v2 = new double[] {
            mC[i][2] * mC[i][0], mC[i][2] * mC[i][1], mC[i][2] * mC[i][2]};
        g[2*mImages] = new double[9]; // g is (2*mImages + 1) X 9;
        for (j = 0; j &lt; 3; ++j) { 
            g[2*mImages][j] = v0[j];                
            g[2*mImages][3+j] = v1[j];
<span class="nc" id="L2078">            g[2*mImages][6+j] = v2[j];               </span>
        }
<span class="nc" id="L2080">        </span>
<span class="nc" id="L2081">        double[] c = new double[2*mImages + 1];</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">        c[2*mImages] = 1;</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">        </span>
        double[][] gInv = MatrixUtil.pseudoinverseFullColumnRank(g);
<span class="nc" id="L2085">        double[] iVector = MatrixUtil.multiplyMatrixByColumnVector(gInv, c);</span>
        assert(iVector.length == 9);
<span class="nc" id="L2087">        </span>
        // 3X3
        double[][] ell = new double[3][3];
<span class="nc" id="L2090">        ell[0] = new double[]{iVector[0], iVector[1], iVector[2]};</span>
        ell[1] = new double[]{iVector[1], iVector[3], iVector[4]};
<span class="nc" id="L2092">        ell[2] = new double[]{iVector[2], iVector[4], iVector[5]};</span>

        // Q can be determined :
<span class="nc" id="L2095">        //   as the square root of ell,</span>
        //   or with the Cholesky decomposition
<span class="nc" id="L2097">        //   or with eigendecomposition</span>

        double eps = 1e-5;

        SymmDenseEVD evd = SymmDenseEVD.factorize(new DenseMatrix(ell));
        double[][] ellSigmaSqrt = MatrixUtil.zeros(evd.getEigenvalues().length, evd.getEigenvalues().length);
        for (i = 0; i &lt; ellSigmaSqrt.length; ++i) {
            if (ellSigmaSqrt[i][i] &lt; 0) {
                // replace with very small value
                ellSigmaSqrt[i][i] = eps;
            } else {
                ellSigmaSqrt[i][i] = Math.sqrt(ellSigmaSqrt[i][i]);
            }
        }
        double[][] lEig = MatrixUtil.convertToRowMajor(evd.getEigenvectors());
        // 3X3
        double[][] q = MatrixUtil.multiply(lEig, ellSigmaSqrt);
        
        // (2*mImages)X3
        double[][] _M = MatrixUtil.multiply(mC, q);
        // 3XnFeatures
        double[][] _S = MatrixUtil.multiply(MatrixUtil.pseudoinverseRankDeficient(q), sC);
                        
        /*
        --------------------------------
        Paraperspective Motion Recovery
        --------------------------------
        eqn(19) :
         `i_f = z_f * m_f + x_f * `k_f
         `j_f = z_f * n_f + y_f * `k_f

         Since the `i, `j, `k  produced must be orthonormal,
            they can be written as functions of only 3 rotational variables.
            We can then view the problem as, for each frame f,
              solving an overconstrained system of 6 equations
              (the expansion of (19) to each of its vector components)
              in 4 variables (the 3 rotational variables and zs).
            
              `i_f[0] = z_f * m_f[0] + x_f * `k_f[0]
              `i_f[1] = z_f * m_f[1] + x_f * `k_f[1]
              `i_f[2] = z_f * m_f[2] + x_f * `k_f[2]
              `j_f[0] = z_f * n_f[0] + y_f * `k_f[0]
              `j_f[1] = z_f * n_f[1] + y_f * `k_f[1]
              `j_f[2] = z_f * n_f[2] + y_f * `k_f[2]
        
          using the equalities of `k_f terms:
           ==&gt; `i_f[0] = `j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f)
           ==&gt; `i_f[1] = `j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*z_f*(x_f/y_f)
           ==&gt; `i_f[2] = `j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*z_f*(x_f/y_f)

        rewrite the 6 eqns of (19)
          `j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f) = z_f * m_f[0] + x_f * `k_f[0]
          `j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*z_f*(x_f/y_f) = z_f * m_f[1] + x_f * `k_f[1]
          `j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*z_f*(x_f/y_f) = z_f * m_f[2] + x_f * `k_f[2]
          `j_f[0] = z_f * n_f[0] + y_f * `k_f[0]
          `j_f[1] = z_f * n_f[1] + y_f * `k_f[1]
          `j_f[2] = z_f * n_f[2] + y_f * `k_f[2]
        rewrite again:
<span class="nc" id="L2155">          `j_f[0]*(x_f/y_f) + m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f) - z_f * m_f[0] - x_f * `k_f[0] = 0</span>
          `j_f[1]*(x_f/y_f) + m_f[1]*z_f - n_f[1]*z_f*(x_f/y_f) - z_f * m_f[1] - x_f * `k_f[1] = 0
          `j_f[2]*(x_f/y_f) + m_f[2]*z_f - n_f[2]*z_f*(x_f/y_f) - z_f * m_f[2] - x_f * `k_f[2] = 0
<span class="nc" id="L2158">          `j_f[0] - z_f * n_f[0] - y_f * `k_f[0] = 0</span>
<span class="nc" id="L2159">          `j_f[1] - z_f * n_f[1] - y_f * `k_f[1] = 0</span>
<span class="nc" id="L2160">          `j_f[2] - z_f * n_f[2] - y_f * `k_f[2] = 0</span>

       factor:
<span class="nc bnc" id="L2163" title="All 2 branches missed.">          jf0                  jf1             jf2            kf0           kf1            kf2         const</span>
<span class="nc" id="L2164">        --------------------------------------------------------------------------------------------------------------------</span>
<span class="nc" id="L2165">         (x_f/y_f)               0              0            -x_f             0            0           m_f[0]*z_f - n_f[0]*(z_f*x_f/y_f) - z_f * m_f[0]</span>
<span class="nc" id="L2166">            0                 (x_f/y_f)         0              0            -x_f           0           m_f[1]*z_f - n_f[1]*(z_f*x_f/y_f) - z_f * m_f[1]</span>
<span class="nc" id="L2167">            0                    0           (x_f/y_f)         0              0           -x_f         m_f[1]*z_f - n_f[1]*(z_f*x_f/y_f) - z_f * m_f[1]</span>
<span class="nc" id="L2168">            1                    0              0            -y_f             0            0           -z_f * n_f[0]</span>
            0                    1              0              0            -y_f           0           -z_f * n_f[1]
<span class="nc" id="L2170">            0                    0              1              0              0           -y_f         -z_f * n_f[2]</span>
<span class="nc" id="L2171">           </span>
<span class="nc bnc" id="L2172" title="All 2 branches missed.">         also, as in eqn (17), use arithmetic mean for (1/z_f^2):</span>
<span class="nc" id="L2173">           z_f = sqrt(2/( |m_f|^2/(1+x_f^2) + |n_f|^2/(1+y_f^2)))</span>
<span class="nc" id="L2174">        */</span>
        // TODO: revisit this for most robust solution
        double[][] _M2 = new double[3*mImages][3]; // holding all i_f, then j_f, then k_f
<span class="nc" id="L2177">        double xDivY, zf, mfsq, nfsq, tmp;</span>
<span class="nc" id="L2178">        double[] mf, nf;</span>
<span class="nc" id="L2179">        double[] zfs = new double[mImages];</span>
        double[] cs = new double[6];
<span class="nc" id="L2181">        double[][] g2 = new double[6][6];</span>
<span class="nc" id="L2182">        double[][] g2Inv;</span>
<span class="nc" id="L2183">        double[] i2Vector;</span>
<span class="nc" id="L2184">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="nc" id="L2185">            xf = t[i];</span>
<span class="nc" id="L2186">            yf = t[mImages + i];</span>
<span class="nc" id="L2187">            xDivY = xf/yf;</span>
<span class="nc" id="L2188">            mf = _M[i];</span>
<span class="nc" id="L2189">            nf = _M[mImages + i];</span>
<span class="nc" id="L2190">            </span>
<span class="nc" id="L2191">            mfsq = 0;</span>
<span class="nc" id="L2192">            nfsq = 0;</span>
            for (j = 0; j &lt; mf.length; ++j) {
<span class="nc" id="L2194">                mfsq += (mf[j]*mf[j]);</span>
<span class="nc" id="L2195">                nfsq += (nf[j]*nf[j]);</span>
<span class="nc bnc" id="L2196" title="All 4 branches missed.">            }</span>
            //z_f = sqrt(2/( |m_f|^2/(1+x_f^2) + |n_f|^2/(1+y_f^2)))
            tmp = (mfsq/(1. + xf*xf)) + (nfsq/(1. + yf*yf));
<span class="nc" id="L2199">            zf = Math.sqrt(2./tmp);</span>
            zfs[i] = zf;
<span class="nc" id="L2201">              </span>
            g2[0] = new double[]{xDivY, 0, 0, -xf, 0, 0};
<span class="nc" id="L2203">            cs[0] = (-mf[0]*zf + nf[0]*(zf*xDivY) + zf*mf[0]);</span>
            g2[1] = new double[]{0, xDivY, 0, 0, -xf, 0,};
            cs[1] = (-mf[1]*zf + nf[1]*(zf*xDivY) + zf*mf[1]);
            g2[2] = new double[]{0, 0, xDivY, 0, 0, -xf};
            cs[2] = (-mf[2]*zf + nf[2]*(zf*xDivY) + zf*mf[2]);
            g2[3] = new double[]{1, 0, 0, -yf, 0, 0};
            cs[3] = zf*nf[0];
            g2[4] = new double[]{0, 1, 0, 0, -yf, 0};
            cs[4] = zf*nf[1];
            g2[5] = new double[]{0, 0, 1, 0, 0, -yf};
            cs[5] = zf*nf[2];
            
            g2Inv = MatrixUtil.pseudoinverseRankDeficient(g2);
            i2Vector = MatrixUtil.multiplyMatrixByColumnVector(g2Inv, cs);
            assert(i2Vector.length == 6);
            
            // j_f
            _M2[mImages + i] = new double[]{i2Vector[0], i2Vector[1], i2Vector[2]}; 
<span class="nc" id="L2221">            // k_f</span>
<span class="nc" id="L2222">            _M2[2*mImages + i] = new double[]{i2Vector[3], i2Vector[4], i2Vector[5]};</span>
<span class="nc" id="L2223">            // i_f</span>
<span class="nc" id="L2224">            _M2[i] = MatrixUtil.crossProduct(_M2[mImages + i], _M2[2*mImages + i]);            </span>
<span class="nc" id="L2225">        }</span>
<span class="nc" id="L2226">           </span>
<span class="nc" id="L2227">        /*</span>
<span class="nc" id="L2228">        from Tomasi &amp; Kanade 1992:</span>
<span class="nc" id="L2229">        If desired, align the ^Lfirst camera reference system with the world</span>
        reference system by forming the products R*R_0 and R_0^T*S,
<span class="nc" id="L2231">        where the orthonormal matrix R_0 = [i1 j1 k1] rotates the ^Lfirst camera</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">        reference system into the identity matrix</span>
<span class="nc" id="L2233"></span>
        i0x i0y i0z    *  r0ix  r0jx  r0kx   = (i0 dot r0i)  (i0 dot r0j) (i0 dot r0k)
<span class="nc" id="L2235">        i1x i1y i1z       r0iy  r0jy  r0ky</span>
<span class="nc" id="L2236">        i2x i2y i2z       r0iz  r0jz  r0kz</span>
        i3x i3y i3z
        ...
        j0x j0y j0z
        j1x j1y j1z
        */
        double[] i1 = Arrays.copyOf(_M2[0], _M2[0].length);
        double i1Norm = MatrixUtil.lPSum(i1, 2);
        MatrixUtil.multiply(i1, 1./i1Norm);
        double[] j1 = Arrays.copyOf(_M2[mImages], _M2[mImages].length);
        double j1Norm = MatrixUtil.lPSum(j1, 2);
        MatrixUtil.multiply(j1, 1./j1Norm);
        double[] k1 = Arrays.copyOf(_M2[2*mImages], _M2[2*mImages].length);
        double k1Norm = MatrixUtil.lPSum(k1, 2);
        MatrixUtil.multiply(k1, 1./k1Norm);

        double[][] r0 = new double[3][3];
        for (i = 0; i &lt; 3; ++i) {
            r0[i] = new double[]{i1[i], j1[i], k1[i]};
        }
        _M2 = MatrixUtil.multiply(_M2, r0);
        _S = MatrixUtil.multiply(MatrixUtil.transpose(r0), _S);
        
        /*
        Poelman &amp; Kanade, last paragraph, Sect 3.4:
        All that remain to be computed are the translations for each frame. 
        We calculate the depth z_f from (15).  
        Once we know we x_f, y_f, z_f, `i_f, `j_f, `k_f 
        we can calculate `t_f using (4) and (5).
        
        eqn(4):
            z_f = -t_f dot k_f
        eqn (5):
<span class="nc" id="L2269">            x_f = (-1/z_f)*(t_f dot i_f)</span>
<span class="nc" id="L2270">            and</span>
            y_f = (-1/z_f)*(t_f dot j_f)

<span class="nc" id="L2273">        use z_f equalities:</span>
<span class="nc bnc" id="L2274" title="All 2 branches missed.">            z_f = -t_f dot k_f</span>
<span class="nc" id="L2275">                = -tf[0]*kf[0] + -tf[1]*kf[1] + -tf[2]*kf[2]</span>
<span class="nc" id="L2276"></span>
<span class="nc" id="L2277">            z_f = (-1/x_f) * (t_f dot i_f)</span>
                = -(1/xf)*tf[0]*if[0] + -(1/xf)*tf[1]*if[1] + -(1/xf)*tf[2]*if[2]

            z_f = (-1/y_f) * (t_f dot j_f)
                = -(1/yf)*tf[0]*jf[0] + -(1/yf)*tf[1]*jf[1] + -(1/yf)*tf[2]*jf[2]
<span class="nc" id="L2282">            </span>
<span class="nc" id="L2283">        factor:</span>
<span class="nc" id="L2284">           tf[0]           tf[1]           tf[2]         const</span>
           -------------------------------------------
<span class="nc" id="L2286">           -kf[0]          -kf[1]         -kf[2]         -zf</span>
<span class="nc" id="L2287">           -(1/xf)*if[0]   -(1/xf)*if[1]  -(1/xf)*if[2]  -zf</span>
<span class="nc" id="L2288">           -(1/yf)*jf[0]   -(1/yf)*jf[1]  -(1/yf)*jf[2]  -zf</span>
        */
<span class="nc" id="L2290">        double[][] trans = new double[mImages][3];</span>
<span class="nc" id="L2291">        double[][] tf = MatrixUtil.zeros(3, 3);</span>
<span class="nc" id="L2292">        double[][] g3Inv;</span>
        double[] i3Vector;
<span class="nc" id="L2294">        cs = new double[3];</span>
        for (i = 0; i &lt; mImages; ++i) {
<span class="nc" id="L2296">            xf = t[i];</span>
<span class="nc" id="L2297">            yf = t[mImages + i];</span>
<span class="nc bnc" id="L2298" title="All 4 branches missed.">            zf = zfs[i];</span>
            
<span class="nc" id="L2300">            // i_f[i] is _M2[i]</span>
            // j_f[i] is _M2[mImages + i]
            // k_f[i] is _M2[2*mImages + i]
            tf[0][0] = -_M2[2*mImages + i][0];
<span class="nc" id="L2304">            tf[0][1] = -_M2[2*mImages + i][1];</span>
            tf[0][2] = -_M2[2*mImages + i][2];
<span class="nc bnc" id="L2306" title="All 2 branches missed.">            </span>
<span class="nc" id="L2307">            tf[1][0] = _M2[i][0]*(-1./xf);</span>
<span class="nc" id="L2308">            tf[1][1] = _M2[i][1]*(-1./xf);</span>
<span class="nc" id="L2309">            tf[1][2] = _M2[i][2]*(-1./xf);</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">            </span>
<span class="nc" id="L2311">            tf[2][0] = _M2[mImages + i][0]*(-1./yf);</span>
<span class="nc" id="L2312">            tf[2][1] = _M2[mImages + i][1]*(-1./yf);</span>
<span class="nc" id="L2313">            tf[2][2] = _M2[mImages + i][2]*(-1./yf);</span>
            
            Arrays.fill(cs, zf);
            
<span class="nc" id="L2317">            g3Inv = MatrixUtil.pseudoinverseRankDeficient(tf);</span>
<span class="nc" id="L2318">            i3Vector = MatrixUtil.multiplyMatrixByColumnVector(g3Inv, cs);</span>
<span class="nc" id="L2319">            assert(i3Vector.length == 3);</span>
<span class="nc" id="L2320">            </span>
            trans[i] = new double[]{i3Vector[0], i3Vector[1], i3Vector[2]};
<span class="nc" id="L2322">        }</span>
        
        // reshape _M2 into a stack of rotation matrices, one per image.
        double[][] rotStack = MatrixUtil.zeros(3*mImages, 3);
<span class="fc" id="L2326">        double[] ic, jc, kc;</span>
<span class="fc" id="L2327">        for (i = 0; i &lt; mImages; ++i) {</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">            ic = _M2[i];</span>
<span class="fc" id="L2329">            jc = _M2[mImages + i];</span>
<span class="fc bfc" id="L2330" title="All 2 branches covered.">            kc = _M2[2*mImages + i];</span>
<span class="fc" id="L2331">            for (j = 0; j &lt; 3; ++j) {</span>
                rotStack[i*3 + j][0] = ic[j]; 
<span class="fc" id="L2333">                rotStack[i*3 + j][1] = jc[j];</span>
                rotStack[i*3 + j][2] = kc[j];
<span class="fc" id="L2335">            }</span>
        }
        
        ParaperspectiveProjectionResults results = new ParaperspectiveProjectionResults();
<span class="fc" id="L2339">        results.XW = _S;</span>
        results.rotationMatrices = rotStack;
        results.translationVectors = trans;
          
        return results;        
    }
    
    private static DenseMatrix extractIndices(DenseMatrix m, List&lt;Integer&gt; inlierIndexes) {
<span class="fc" id="L2347">        DenseMatrix out = new DenseMatrix(m.numRows(), inlierIndexes.size());</span>
        int r = 0;
        for (int i = 0; i &lt; inlierIndexes.size(); ++i) {
            int idx = inlierIndexes.get(i);
            for (int j = 0; j &lt; m.numRows(); ++j) {
                out.add(j, r, m.get(j, idx));
<span class="nc" id="L2353">            }</span>
<span class="nc" id="L2354">            r++;</span>
<span class="nc" id="L2355">        }</span>
<span class="nc" id="L2356">        return out;</span>
<span class="nc" id="L2357">    }</span>

<span class="nc" id="L2359">    private static double[] gT(double[] a, double[] b) {</span>
        double[] gT = new double[]{
<span class="nc" id="L2361">            a[0]*b[0], </span>
<span class="nc" id="L2362">            a[0]*b[1] + a[1]*b[0],</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">            a[0]*b[2] + a[2]*b[0],</span>
<span class="nc" id="L2364">            a[1]*b[1],</span>
<span class="nc" id="L2365">            a[1]*b[2] + a[2]*b[1],</span>
            a[2]*b[2]
<span class="nc" id="L2367">        };</span>
<span class="nc" id="L2368">        return gT;</span>
    }
<span class="nc" id="L2370"></span>
    private static double[][] extractAndNormalize(double[][] x, int imageNumber, 
<span class="nc bnc" id="L2372" title="All 2 branches missed.">        int nFeatures, double[] outputNorm) {</span>
<span class="nc" id="L2373">        </span>
<span class="nc" id="L2374">        double[][] xN = new double[3][nFeatures];</span>
<span class="nc" id="L2375">        xN[0] = new double[nFeatures];</span>
        xN[1] = new double[nFeatures];
<span class="nc" id="L2377">        xN[2] = new double[nFeatures];</span>
        Arrays.fill(xN[2], 1);
        
<span class="nc" id="L2380">        int imageIdx = (x.length/nFeatures)*imageNumber;</span>
<span class="nc" id="L2381">        </span>
<span class="nc" id="L2382">        double cen0 = 0;</span>
        double cen1 = 0;
<span class="nc bnc" id="L2384" title="All 2 branches missed.">        for (int i = 0; i &lt; nFeatures; ++i) {</span>
<span class="nc" id="L2385">            cen0 += x[0][imageIdx + i];</span>
<span class="nc" id="L2386">            cen1 += x[0][imageIdx + i];</span>
        }
        cen0 /= (double)nFeatures;
<span class="nc" id="L2389">        cen1 /= (double)nFeatures;</span>

        double scale = 0;
        double diffX, diffY;
        for (int i = 0; i &lt; nFeatures; ++i) {
            diffX = x[0][imageIdx + i] - cen0;
<span class="nc bnc" id="L2395" title="All 2 branches missed.">            diffY = x[0][imageIdx + i] - cen1;</span>
<span class="nc" id="L2396">            scale += (diffX*diffX + diffY*diffY);</span>
        }
        scale = Math.sqrt(scale/(2.*(nFeatures - 1.)));
<span class="nc" id="L2399">        // to use std dev instead: scale = Math.sqrt(scale/(n-1.));</span>
        
        outputNorm[imageNumber*3 + 0] = cen0;
        outputNorm[imageNumber*3 + 1] = cen1;
        outputNorm[imageNumber*3 + 2] = scale;
        
        for (int i = 0; i &lt; nFeatures; ++i) {
            xN[0][i] = (x[0][imageIdx + i] - cen0)/scale;
            xN[1][i] = (x[1][imageIdx + i] - cen1)/scale;
<span class="nc bnc" id="L2408" title="All 4 branches missed.">        }</span>
<span class="nc bnc" id="L2409" title="All 4 branches missed.">        </span>
<span class="nc bnc" id="L2410" title="All 4 branches missed.">        return xN;</span>
<span class="nc bnc" id="L2411" title="All 4 branches missed.">    }</span>

    private static void calculateLeftEpipole(DenseMatrix fundamentalMatrix,
<span class="nc bnc" id="L2414" title="All 2 branches missed.">        double[] outputE01) throws NotConvergedException {</span>
<span class="nc" id="L2415">        </span>
        if (outputE01.length != 3) {
<span class="nc" id="L2417">            throw new IllegalArgumentException(&quot;outputE01 length must be 3&quot;);</span>
        }
        
<span class="nc" id="L2420">        SVDProducts svdE = MatrixUtil.performSVD(fundamentalMatrix);</span>
<span class="nc" id="L2421">        </span>
<span class="nc" id="L2422">        /*</span>
<span class="nc" id="L2423">         The left epipole is e1 = last column of U / last item of that column</span>
         It is  the left image position of the epipolar projection of the right camera center
         The right epipole e2 = last row of V / last item of that row
         It is the right image position of the epipolar projection of the left camera center
        */
        
        assert(svdE.u[0].length == 3);
        assert(svdE.u.length == 3);
        assert(svdE.vT[0].length == 3);
        assert(svdE.vT.length == 3);
        
        //double e1Div = svdE.vT[2][2];
        for (int i = 0; i &lt; 3; i++) {
            outputE01[i] = svdE.vT[2][i];///e1Div;
        }
    }

    private static void extractColumn(double[][] x, int idx, double[] outputPoint) {
        outputPoint[0] = x[0][idx];
        outputPoint[1] = x[1][idx];
        outputPoint[2] = x[2][idx];
    }
    
    public static class ProjectionResults {
        /**
         * world coordinate system points in matrix of size 4 X nFeatures.
         * The points are stacked along columns sequentially.
         */
        public double[][] XW;
        
        /**
         * the projection matrices stacked along rows for each image.
         * so projection for image 0 will be in rows [0, 3);
         * projection for image 1 will be in rows [3, 6), etc.
         * This matrix's size is 3*nImages X 4
         */
        public double[][] projectionMatrices;
    }
    
    public static class OrthographicProjectionResults {
        /**
         * world coordinate system points
         */
        public double[][] XW;
        
        /**
         * the rotation matrices stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public double[][] rotationMatrices;
    }
    
    public static class ParaperspectiveProjectionResults {
        /**
         * world coordinate system points
         */
        private double[][] XW;
        
        /**
         * the rotation matrices (as extrinsic parameters) stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        private double[][] rotationMatrices;
        
        /**
         * the translation vectors (as extrinsic parameters) 
         * stacked along rows for each image.
         * 
         */
        private double[][] translationVectors;

        /**
         * @return the XW
         */
        public double[][] getXW() {
            return XW;
        }

        /**
         * @param XW the XW to set
         */
        public void setXW(double[][] XW) {
            this.XW = XW;
        }

        /**
         * @return the rotationMatrices (as extrinsic parameters) 
         * stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public double[][] getRotationStack() {
            return rotationMatrices;
        }

        /**
         * @param rotationMatrices the rotationMatrices to set.
         * the rotation matrices (as extrinsic parameters) stacked along rows for each image.
         * so rotation for image 0 will be in rows [0, 3);
         * rotation for image 1 will be in rows [3, 6), etc.
         */
        public void setRotationStack(double[][] rotationMatrices) {
            this.rotationMatrices = rotationMatrices;
        }

        /**
         * @return the translationVectors
         */
        public double[][] getTranslationVectorStack() {
            return translationVectors;
        }

        /**
         * @param translationVectors the translationVectors to set
         */
        public void setTranslationVectorStack(double[][] translationVectors) {
            this.translationVectors = translationVectors;
        }
        
        public double[][] getExtrinsicProjection(int imageNumber) {
            double[][] p = new double[3][4];
            for (int i = 0; i &lt; 3; ++i) {
                p[i] = new double[4];
                System.arraycopy(rotationMatrices[imageNumber*3 + i], 0, p[i], 0, 3);
                p[i][4] = translationVectors[imageNumber][i];
            }
            return p;
        }
    }

    public static class ReconstructionResults {
        double[][] XW;
        double[][] k1Intr;
        double[][] k2Intr;
        double[][] k1ExtrRot;
        double[] k1ExtrTrans;
        double[][] k2ExtrRot;
        double[] k2ExtrTrans;
        double[][] essentialMatrix;
        SVDProducts svd;
        double[][] fundamentalMatrix;
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;XW=\n&quot;);
            if (XW != null) {
                sb.append(FormatArray.toString(XW, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 intrinsic=\n&quot;);
            if (k1Intr != null) {
                sb.append(FormatArray.toString(k1Intr, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 extrinsic rotation=\n&quot;);
            if (k1ExtrRot != null) {
                sb.append(FormatArray.toString(k1ExtrRot, &quot;%.4e&quot;));
            }
            sb.append(&quot;k1 extrinsic translation=\n&quot;);
            if (k1ExtrTrans != null) {
                sb.append(FormatArray.toString(k1ExtrTrans, &quot;%.4e&quot;));
                sb.append(&quot;\n&quot;);
            }
            sb.append(&quot;k2 intrinsic=\n&quot;);
            if (k2Intr != null) {
                sb.append(FormatArray.toString(k2Intr, &quot;%.4e&quot;));
            }
            sb.append(&quot;k2 extrinsic rotation=\n&quot;);
            if (k2ExtrRot != null) {
                sb.append(FormatArray.toString(k2ExtrRot, &quot;%.4e&quot;));
            }
            sb.append(&quot;k2 extrinsic translation=\n&quot;);
            if (k2ExtrTrans != null) {
                sb.append(FormatArray.toString(k2ExtrTrans, &quot;%.4e&quot;));
                sb.append(&quot;\n&quot;);
            }
            return sb.toString();
        }
    }
    
      /**
     * among the 4 rotation and translation combinations from R1, R1, T1, and T2, 
     * select the one with the largest number of projected Z coordinates which are
     * positive, that is, in front of both cameras.
     * NOTE that inaccuracies in this chirality are larger for points further 
     * away from the cameras and closer to the plane at infinity.
<span class="fc" id="L2610">     * NOTE that the determinants of R1 and R2 should have already been checked to be +1.</span>
     * @param x1 image 1 portion of the correspondence pairs.
<span class="pc bpc" id="L2612" title="1 of 2 branches missed.">     * @param x2 image 2 portion of the correspondence pairs.</span>
<span class="nc" id="L2613">     * @param k1 intrinsic camera matrix for camera 1</span>
     * @param k2 intrinsic camera matrix for camera 2
<span class="pc bpc" id="L2615" title="1 of 2 branches missed.">     * @param R1 rotation matrix whose determinant is +1</span>
<span class="nc" id="L2616">     * @param R2 rotation matrix whose determinant is +1</span>
     * @param t1 translation vector (the direction between camera centers)
     * @param t2 translation vector (the direction between camera centers)
     * @param rSelected output variable holding the R1 or R2, whichever was the 
     * first found as a valid solution.
     * @param tSelected output variable holding the t1 or t2, whichever was the 
<span class="fc" id="L2622">     * first found as a valid solution.</span>
<span class="fc" id="L2623">     * @param outputX the real world coordinates of the projection of x1 and x2 using</span>
     * triangulation. else null if no valid solution was found
     */
<span class="fc" id="L2626">    private static void bestInCheiralityTest(double[][] x1, double[][] x2, </span>
<span class="fc" id="L2627">        double[][] k1, double[][] k2,</span>
<span class="fc" id="L2628">        double[][] R1, double[][] R2, double[] t1, double[] t2, </span>
<span class="fc" id="L2629">        double[][] rSelected, double[] tSelected, double[][] outputX) {</span>
<span class="fc" id="L2630">    </span>
        int n = x1[0].length;
        
        if (outputX.length != 4) {
<span class="fc" id="L2634">            throw new IllegalArgumentException(&quot;outputX.length must be 4&quot;);</span>
        }
<span class="fc" id="L2636">        if (outputX[0].length != n) {</span>
<span class="fc" id="L2637">            throw new IllegalArgumentException(&quot;outputX[0].length must be the same as x1[0].length&quot;);</span>
<span class="fc bfc" id="L2638" title="All 2 branches covered.">        }</span>
<span class="fc" id="L2639">        </span>
        // for this model, for the first image, the camera extrinsics are
        //    R = I and t = [0], which leaves all rotation and translation in
<span class="fc" id="L2642">        //    the 2nd camera extrinsics w.r.t. the first.</span>
<span class="fc" id="L2643">        double[][] k1ExtrRot = MatrixUtil.createIdentityMatrix(3);</span>
<span class="fc" id="L2644">        double[] k1ExtrTrans = new double[3];</span>
<span class="fc" id="L2645">        </span>
        // save the first that pass the tests for Z&gt;=0.
<span class="fc bfc" id="L2647" title="All 2 branches covered.">        double[][] bestR = null;</span>
<span class="fc" id="L2648">        double[] bestT = null;</span>
<span class="fc" id="L2649">        double[][] bestXW = null;</span>
        String bestLabel = null;
        int bestNPosZ = Integer.MIN_VALUE;
        
        double[][] XW;
<span class="fc bfc" id="L2654" title="All 2 branches covered.">        double[] XWPt;</span>
<span class="fc bfc" id="L2655" title="All 4 branches covered.">        String label = null;</span>
        
<span class="fc" id="L2657">        XWPt = new double[4];</span>
<span class="fc" id="L2658">        XW = new double[4][n];</span>
<span class="fc" id="L2659">        for (int i = 0; i &lt; 4; ++i) {</span>
<span class="fc" id="L2660">            XW[i] = new double[n];</span>
        }
            
<span class="fc" id="L2663">        double[][] rTst = null;</span>
<span class="fc" id="L2664">        double[] tTst = null;</span>
<span class="fc" id="L2665">        double[][] x1Pt = new double[3][1];</span>
<span class="fc" id="L2666">        double[][] x2Pt = new double[3][1];</span>
        int i, j, ii;
        for (i = 0; i &lt; 3; ++i) {
<span class="fc" id="L2669">            x1Pt[i] = new double[1];</span>
<span class="fc" id="L2670">            x2Pt[i] = new double[1];</span>
<span class="fc" id="L2671">        }</span>
<span class="fc" id="L2672">        </span>
        int nPosZ; 
        
<span class="fc" id="L2675">        for (j = 0; j &lt; 4; ++j) {</span>
<span class="fc" id="L2676">            switch(j) {</span>
<span class="fc" id="L2677">                case 0: {</span>
                    label = &quot;R1, T1&quot;;
                    rTst = R1;
                    tTst = t1;
<span class="fc" id="L2681">                    break;</span>
<span class="fc bfc" id="L2682" title="All 2 branches covered.">                }</span>
<span class="fc bfc" id="L2683" title="All 2 branches covered.">                case 1: {</span>
<span class="fc" id="L2684">                    label = &quot;R1, T2&quot;;</span>
<span class="fc" id="L2685">                    rTst = R1;</span>
                    tTst = t2;
                    break;
<span class="fc" id="L2688">                }</span>
                case 2: {
                    label = &quot;R2, T1&quot;;
                    rTst = R2;
<span class="fc bfc" id="L2692" title="All 2 branches covered.">                    tTst = t1;</span>
<span class="fc" id="L2693">                    break;</span>
                }
<span class="fc bfc" id="L2695" title="All 2 branches covered.">                default: {                    </span>
<span class="fc" id="L2696">                    label = &quot;R2, T2&quot;;</span>
                    rTst = R2;
                    tTst = t2;
<span class="fc bfc" id="L2699" title="All 2 branches covered.">                    break;</span>
<span class="fc" id="L2700">                }</span>
<span class="fc" id="L2701">            }</span>
<span class="fc" id="L2702">            nPosZ = 0;</span>
<span class="fc" id="L2703">            for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L2704">                for (ii = 0; ii &lt; 3; ++ii) {</span>
                    x1Pt[ii][0] = x1[ii][i];
                    x2Pt[ii][0] = x2[ii][i];
                }
<span class="pc bpc" id="L2708" title="1 of 2 branches missed.">                //</span>
<span class="nc" id="L2709">                XWPt = Triangulation.calculateWCSPoint(</span>
                    k1, k1ExtrRot, k1ExtrTrans, 
                    k2, rTst, tTst, 
                    x1Pt, x2Pt);
<span class="fc bfc" id="L2713" title="All 2 branches covered.">                if (XWPt[2] &gt;= 0) {</span>
<span class="fc" id="L2714">                    nPosZ++;</span>
                }
<span class="fc" id="L2716">                for (ii = 0; ii &lt; 4; ++ii) {</span>
                    XW[ii][i] = XWPt[ii];
<span class="fc" id="L2718">                } </span>
            }
<span class="fc" id="L2720">            if (nPosZ &gt; bestNPosZ) {</span>
<span class="fc" id="L2721">                bestNPosZ = nPosZ;</span>
                bestR = rTst;
<span class="fc" id="L2723">                bestT = tTst;</span>
                bestLabel = label;
<span class="fc bfc" id="L2725" title="All 2 branches covered.">                bestXW = MatrixUtil.copy(XW);</span>
<span class="fc" id="L2726">            }</span>
        }
        
<span class="fc" id="L2729">        if (bestR == null) {</span>
            return;
        }
        
        // copy into output variables:
        for (i = 0; i &lt; bestR.length; ++i) {
            System.arraycopy(bestR[i], 0, rSelected[i], 0, bestR[i].length);
        }
        System.arraycopy(bestT, 0, tSelected, 0, bestT.length);
        
        System.out.println(&quot;choosing solution: &quot; + bestLabel);
        //double estimatedRotY = Math.atan(R[0][2]/R[0][0]) * (180./Math.PI);
        double estimatedRotZ = Math.atan(-bestR[1][0]/bestR[1][1]) * (180./Math.PI);
        System.out.printf(&quot;estimated rotation in degrees about z axis from R=%.2f\n&quot;, estimatedRotZ);
<span class="fc" id="L2743">        //System.out.printf(&quot;X_WCS=\n%s\n&quot;, FormatArray.toString(bestXW, &quot;%.3e&quot;));</span>
<span class="fc" id="L2744">        System.out.flush();</span>
<span class="fc" id="L2745">        </span>
<span class="fc" id="L2746">        for (i = 0; i &lt; XW.length; ++i) {</span>
<span class="fc" id="L2747">            System.arraycopy(bestXW[i], 0, outputX[i], 0, bestXW[i].length);</span>
        }
<span class="fc" id="L2749">        </span>
<span class="fc" id="L2750">    }</span>
<span class="fc" id="L2751"></span>
    static void populateWithDet1Rs(MatrixUtil.SVDProducts svdE, 
<span class="fc" id="L2753">        double[][] r1Out, double[][] r2Out, double[][] uOut) {</span>
<span class="fc" id="L2754">        </span>
<span class="fc" id="L2755">        //Szeliski 2010, eqn (7.25)</span>
<span class="fc" id="L2756">        </span>
        // R_Z+90 and R_Z_-90 from 
<span class="fc" id="L2758">        // Ma, Soatto, Kosecká, and Sastry 2012, &quot;An Invitation to 3-D Vision&quot;, pg 121</span>
<span class="fc" id="L2759">        </span>
<span class="fc" id="L2760">        //R_z_90^T  = [ [0, 1, 0], [0, -1, 0], [0, 0, 1] ]</span>
<span class="fc" id="L2761">        //R_z_-90^T = [ [0, -1, 0], [0, 1, 0], [0, 0, 1] ]</span>
         
<span class="fc" id="L2763">        //R_z_90</span>
<span class="fc" id="L2764">        double[][] r90T = new double[3][3];</span>
<span class="fc" id="L2765">        r90T[0] = new double[]{0, 1, 0};</span>
<span class="fc" id="L2766">        r90T[1] = new double[]{-1, 0, 0};</span>
<span class="fc" id="L2767">        r90T[2] = new double[]{0, 0, 1};</span>
        double[][] r90NegT = MatrixUtil.transpose(r90T);
<span class="fc" id="L2769">        </span>
        double[][] u = svdE.u;
        double[][] uNeg = MatrixUtil.copy(u);
<span class="pc bpc" id="L2772" title="1 of 2 branches missed.">        MatrixUtil.multiply(uNeg, -1);</span>
<span class="fc" id="L2773">        </span>
<span class="fc bfc" id="L2774" title="All 2 branches covered.">        double[][] rr1 = MatrixUtil.multiply(MatrixUtil.multiply(u, r90T), svdE.vT);</span>
<span class="fc" id="L2775">        double[][] rr2 = MatrixUtil.multiply(MatrixUtil.multiply(uNeg, r90T), svdE.vT);</span>
        double[][] rr3 = MatrixUtil.multiply(MatrixUtil.multiply(u, r90NegT), svdE.vT);
<span class="nc bnc" id="L2777" title="All 2 branches missed.">        double[][] rr4 = MatrixUtil.multiply(MatrixUtil.multiply(uNeg, r90NegT), svdE.vT);</span>
<span class="nc" id="L2778">        </span>
<span class="nc" id="L2779">        double det1 = MatrixUtil.determinant(rr1);</span>
<span class="nc bnc" id="L2780" title="All 2 branches missed.">        double det2 = MatrixUtil.determinant(rr2);</span>
<span class="nc" id="L2781">        double det3 = MatrixUtil.determinant(rr3);</span>
        double det4 = MatrixUtil.determinant(rr4);
        
<span class="nc" id="L2784">        System.out.printf(&quot;det(r1,r2,r3,r4)=%.3e,%.3e,%.3e,%.3e\n&quot;, det1, det2, det3, det4);</span>
        System.out.printf(&quot;r1:\n%s\n&quot;, FormatArray.toString(rr1, &quot;%.4e&quot;));
<span class="pc bpc" id="L2786" title="1 of 2 branches missed.">        System.out.printf(&quot;r2:\n%s\n&quot;, FormatArray.toString(rr2, &quot;%.4e&quot;));</span>
<span class="pc bpc" id="L2787" title="1 of 2 branches missed.">        System.out.printf(&quot;r3:\n%s\n&quot;, FormatArray.toString(rr3, &quot;%.4e&quot;));</span>
<span class="nc" id="L2788">        System.out.printf(&quot;r4:\n%s\n&quot;, FormatArray.toString(rr4, &quot;%.4e&quot;));</span>
        
<span class="fc" id="L2790">        boolean useUPos = true;</span>
<span class="fc bfc" id="L2791" title="All 2 branches covered.">        </span>
<span class="fc" id="L2792">        int i;</span>
        if (Math.abs(det1 - 1.) &lt; eps) {
<span class="nc bnc" id="L2794" title="All 2 branches missed.">            System.out.printf(&quot;using +U\n&quot;);</span>
<span class="nc bnc" id="L2795" title="All 2 branches missed.">            for (i = 0; i &lt; 3; ++i) {</span>
<span class="nc" id="L2796">                System.arraycopy(rr1[i], 0, r1Out[i], 0, rr1[i].length);</span>
            }
<span class="nc" id="L2798">        } else if (Math.abs(det2 - 1.) &lt; eps) {</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">            System.out.printf(&quot;using -U\n&quot;);</span>
<span class="nc" id="L2800">            useUPos = false;</span>
            for (i = 0; i &lt; 3; ++i) {
                System.arraycopy(rr2[i], 0, r1Out[i], 0, rr2[i].length);
<span class="nc" id="L2803">            }</span>
        } else {
            throw new IllegalStateException(&quot;neither rotation matrix is SO(3)&quot;);
<span class="pc bpc" id="L2806" title="1 of 2 branches missed.">        }</span>
<span class="fc bfc" id="L2807" title="All 2 branches covered.">        if (Math.abs(det3 - 1.) &lt; eps) {</span>
<span class="fc" id="L2808">            if (!useUPos) {</span>
                throw new IllegalStateException(&quot;expecting to need +U&quot;);
            }
<span class="nc bnc" id="L2811" title="All 2 branches missed.">            System.out.printf(&quot;using +U\n&quot;);</span>
<span class="nc" id="L2812">            for (i = 0; i &lt; 3; ++i) {</span>
                System.arraycopy(rr3[i], 0, r2Out[i], 0, rr3[i].length);
            }
<span class="fc" id="L2815">        } else if (Math.abs(det4 - 1.) &lt; eps) {</span>
            if (useUPos) {
                throw new IllegalStateException(&quot;expecting to need -U&quot;);
            }
            System.out.printf(&quot;using -U\n&quot;);
            for (i = 0; i &lt; 3; ++i) {
                System.arraycopy(rr4[i], 0, r2Out[i], 0, rr4[i].length);
            }
        } else {
            throw new IllegalStateException(&quot;neither rotation matrix is SO(3)&quot;);
        }
        
        if (useUPos) {
            for (i = 0; i &lt; 3; ++i) {
                System.arraycopy(u[i], 0, uOut[i], 0, u[i].length);
            }
        } else {
            for (i = 0; i &lt; 3; ++i) {
                System.arraycopy(uNeg[i], 0, uOut[i], 0, uNeg[i].length);
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VoronoiFortunesSweep.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.compGeometry.voronoi</a> &gt; <span class="el_source">VoronoiFortunesSweep.java</span></div><h1>VoronoiFortunesSweep.java</h1><pre class="source lang-java linenums">package algorithms.compGeometry.voronoi;

import algorithms.util.PairFloat;
import algorithms.util.PairInt;
import algorithms.util.PolygonAndPointPlotter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedList;

/**
 * A voronoi diagram is a partitioning of points
 * into cells defined by seed centers.  The cells
 * edges are defined as perpendicular bisectors
 * between 2 seeds, which results in the cells 
 * being regions which are closer to the seed
 * point than to any other seed point.
 * 
 * The sweep line algorithm runtime complexity
 * is  O(n log n).
 * 
  adapted from the following codes:
 
   a port to java of the C++ port of
 * Steven Fortune's original c code.
 * The C++ port by Shane O' Sullivan is at 
 * http://skynet.ie/~sos/mapviewer/voronoi.php
 * and uses a liberal AT&amp;T license.
 * Then 2 ports to java.  
 * https://sourceforge.net/projects/simplevoronoi/postdownload?source=dlp
 * All have liberal licenses listed here.
 
 * The author of this software is Steven Fortune.  Copyright (c) 1994 by AT&amp;T
 * Bell Laboratories.
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 
 * This code was originally written by Stephan Fortune in C code.  I, Shane O'Sullivan,
 * have since modified it, encapsulating it in a C++ class and, fixing memory leaks and
 * adding accessors to the Voronoi Edges.
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
  
 * Java Version by Zhenyu Pan
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 * 
 * in this project:
 * changes to the above java port are essentially 
 * to the comparator and sorting, and an extra check for
 * zero length edges at the end of the method clipLine.
 * Format changes such as camel case are present 
 * here.  Also moved the data classes to inner classes
 * here, and am using specialized classes that already
 * existed in this project such as the PairFloat for 
 * coordinates.
 */
public class VoronoiFortunesSweep {
    
<span class="fc" id="L82">    private static int LE = 0;</span>
<span class="fc" id="L83">    private static int RE = 1;</span>

<span class="fc" id="L85">    private HalfEdge ELleftend = null;</span>
<span class="fc" id="L86">    private HalfEdge ELrightend = null;</span>
    private int ELhashsize;
    private float xmin, xmax, ymin, ymax, deltax, deltay;

<span class="fc" id="L90">    private Site[] sites = null;</span>
<span class="fc" id="L91">    private int nSites = 0;</span>
<span class="fc" id="L92">    private int siteIdx = 0;</span>
    private int sqrtNSites;
<span class="fc" id="L94">    private int nVertices = 0;</span>
<span class="fc" id="L95">    private int nEdges = 0;</span>
    
    private Site bottomsite;
	
    private int	PQcount;
    private int	PQmin;
    private int PQhashsize;
    private HalfEdge[] PQhash;

    private float borderMinX, borderMaxX, borderMinY, borderMaxY;

<span class="fc" id="L106">    private LinkedList&lt;GraphEdge&gt; allEdges = null;</span>

<span class="fc" id="L108">    private float minDistanceBetweenSites = 0;</span>
    
<span class="fc" id="L110">    private HalfEdge[] ELhash = null;</span>
    
<span class="fc" id="L112">    public VoronoiFortunesSweep() {</span>
<span class="fc" id="L113">        allEdges = new LinkedList&lt;GraphEdge&gt;();</span>
<span class="fc" id="L114">    }</span>
    
    public LinkedList&lt;GraphEdge&gt; getAllEdges() {
<span class="fc" id="L117">        return allEdges;</span>
    }
    
    public boolean generateVoronoi(
        float[] xValues, float[] yValues, float minX, float maxX, 
        float minY, float maxY, float minDist) {
        
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (xValues.length != yValues.length) {</span>
<span class="nc" id="L125">            throw new IllegalArgumentException(</span>
            &quot;xValues and yValues must be same length&quot;);
        }
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (xValues.length == 0) {</span>
<span class="nc" id="L129">             throw new IllegalArgumentException(</span>
            &quot;xValues and yValues must not be empty&quot;);
        }

<span class="fc" id="L133">        minDistanceBetweenSites = minDist;</span>
    
<span class="fc" id="L135">        siteIdx = 0;</span>
<span class="fc" id="L136">        nSites = xValues.length;</span>
<span class="fc" id="L137">        nVertices = 0;</span>
<span class="fc" id="L138">        nEdges = 0;</span>
<span class="fc" id="L139">        double sn = (double) nSites + 4;</span>
<span class="fc" id="L140">        sqrtNSites = (int) Math.sqrt(sn);</span>

<span class="fc" id="L142">        sites = new Site[nSites];</span>

<span class="fc" id="L144">        xmin = Float.MAX_VALUE;</span>
<span class="fc" id="L145">        ymin = Float.MAX_VALUE;</span>
<span class="fc" id="L146">        xmax = Float.MIN_VALUE;</span>
<span class="fc" id="L147">        ymax = Float.MIN_VALUE;</span>
        
        int i;
<span class="fc bfc" id="L150" title="All 2 branches covered.">        for(i = 0; i &lt; nSites; i++) {</span>
<span class="fc" id="L151">            sites[i] = new Site();</span>
<span class="fc" id="L152">            sites[i].coord = new PairFloat(xValues[i], yValues[i]);</span>
            // this gets reset after sort:
<span class="fc" id="L154">            sites[i].sitenbr = i;</span>
<span class="fc" id="L155">            sites[i].refcnt = 0;</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (xValues[i] &lt; xmin) {</span>
<span class="fc" id="L158">                xmin = xValues[i];</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            } else if (xValues[i] &gt; xmax) {</span>
<span class="fc" id="L160">                xmax = xValues[i];</span>
            }
            
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (yValues[i] &lt; ymin) {</span>
<span class="fc" id="L164">                ymin = yValues[i];</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            } else if (yValues[i] &gt; ymax) {</span>
<span class="fc" id="L166">                ymax = yValues[i];</span>
            }
            
            //printf(&quot;\n%f %f\n&quot;,xValues[i],yValues[i]);
        }
        
        // N log_2 N
<span class="fc" id="L173">        qsort(sites);</span>
        
        // renumber site numbers
<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (int ii = 0; ii &lt; sites.length; ++ii) {</span>
<span class="fc" id="L177">            sites[ii].sitenbr = ii;</span>
        }
        
<span class="fc" id="L180">        float temp = 0;</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (minX &gt; maxX) {</span>
<span class="nc" id="L182">            temp = minX;</span>
<span class="nc" id="L183">            minX = maxX;</span>
<span class="nc" id="L184">            maxX = temp;</span>
        }
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (minY &gt; maxY) {</span>
<span class="nc" id="L187">            temp = minY;</span>
<span class="nc" id="L188">            minY = maxY;</span>
<span class="nc" id="L189">            maxY = temp;</span>
        }
<span class="fc" id="L191">        borderMinX = minX;</span>
<span class="fc" id="L192">        borderMinY = minY;</span>
<span class="fc" id="L193">        borderMaxX = maxX;</span>
<span class="fc" id="L194">        borderMaxY = maxY;</span>
        
<span class="fc" id="L196">        deltay = ymax - ymin;</span>
<span class="fc" id="L197">        deltax = xmax - xmin;</span>
        
<span class="fc" id="L199">        return voronoi();        </span>
    }
    
    /*
       implicit parameters: nsites, sqrt_nsites, 
       xmin, xmax, ymin, ymax, deltax,
       deltay (can all be estimates). 
       Performance suffers if they are wrong;
       better to make nsites, deltax, 
       and deltay too big than too small. (?)
     */
    private boolean voronoi() {
        
        Site newsite, bot, top, temp, p;
        Site v;
<span class="fc" id="L214">        PairFloat newintstar = null;</span>
        int pm;
        HalfEdge lbnd, rbnd, llbnd, rrbnd, bisector;
        Edge e;

<span class="fc" id="L219">        PQInitialize();</span>
<span class="fc" id="L220">        ELInitialize();</span>

<span class="fc" id="L222">        bottomsite = nextOne();</span>
<span class="fc" id="L223">        newsite = nextOne();</span>
        
        while (true) {
            
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (!PQEmpty()) {</span>
<span class="fc" id="L228">                newintstar = PQMin();</span>
            }
            
            // if the lowest site has a smaller y value than 
            // the lowest vector intersection,
            // process the site otherwise process the vector 
            // intersection

<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (newsite != null</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            &amp;&amp; (PQEmpty() || </span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                newsite.coord.getY() &lt; newintstar.getY() || </span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                (newsite.coord.getY() == newintstar.getY() &amp;&amp; </span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                newsite.coord.getX() &lt; newintstar.getX()))) {</span>
                
                // new site is smallest -this is a site event
                         
                // get the first HalfEdge to the LEFT of the new site
<span class="fc" id="L245">                lbnd = ELLeftBnd((newsite.coord));</span>
                
                // get the first HalfEdge to the RIGHT of the new site
<span class="fc" id="L248">                rbnd = lbnd.ELright;</span>
                
                // if this halfedge has no edge,bot =bottom site 
<span class="fc" id="L251">                bot = rightReg(lbnd);</span>
                
                // create a new edge that bisects
<span class="fc" id="L254">                e = bisect(bot, newsite);</span>

                // create a new HalfEdge, setting its ELpm field to 0
<span class="fc" id="L257">                bisector = HECreate(e, LE);</span>
                
                // insert this new bisector edge between the left 
                // and right vectors in a linked list
<span class="fc" id="L261">                ELInsert(lbnd, bisector);</span>

                // if the new bisector intersects with the left edge,
                // remove the left edge's vertex, and put in the new one
<span class="fc bfc" id="L265" title="All 2 branches covered.">                if ((p = intersect(lbnd, bisector)) != null) {</span>
<span class="fc" id="L266">                    PQDelete(lbnd);</span>
<span class="fc" id="L267">                    PQInsert(lbnd, p, dist(p, newsite));</span>
                }
<span class="fc" id="L269">                lbnd = bisector;</span>
                
                // create a new HalfEdge, setting its ELpm field to 1
<span class="fc" id="L272">                bisector = HECreate(e, RE);</span>
                 
                // insert the new HE to the right of the original bisector
                // earlier in the IF stmt
<span class="fc" id="L276">                ELInsert(lbnd, bisector);</span>
                
                // if this new bisector intersects with the new HalfEdge
<span class="fc bfc" id="L279" title="All 2 branches covered.">                if ((p = intersect(bisector, rbnd)) != null) {</span>
                    // push the HE into the ordered linked list of vertices
<span class="fc" id="L281">                    PQInsert(bisector, p, dist(p, newsite));</span>
                }
                
                /*System.out.println(
                &quot;  &quot; + bot.sitenbr + &quot; bot=&quot; 
                + sites[bot.sitenbr].coord
                + &quot;  &quot; + newsite.sitenbr + &quot; top=&quot; 
                + sites[newsite.sitenbr].coord);
                */
                
<span class="fc" id="L291">                newsite = nextOne();</span>
                
<span class="fc bfc" id="L293" title="All 2 branches covered.">            } else if (!PQEmpty()) {</span>
            
                // intersection is smallest - this is a vector event
            
                // pop the HalfEdge with the lowest vector off the ordered list
                // of vectors
<span class="fc" id="L299">                lbnd = PQExtractMin();</span>
                
                // get the HalfEdge to the left of the above HE
<span class="fc" id="L302">                llbnd = lbnd.ELleft;</span>
                
                // get the HalfEdge to the right of the above HE
<span class="fc" id="L305">                rbnd = lbnd.ELright;</span>
                
                // get the HalfEdge to the right of the HE to the right of the
                // lowest HE
<span class="fc" id="L309">                rrbnd = rbnd.ELright;</span>
                
                // get the Site to the left of the left HE which it bisects
<span class="fc" id="L312">                bot = leftReg(lbnd);</span>
                
                // get the Site to the right of the right HE which it bisects
<span class="fc" id="L315">                top = rightReg(rbnd);</span>

                // get the vertex that caused this event
<span class="fc" id="L318">                v = lbnd.vertex;</span>
                
                // set the vertex number - couldn't do this
<span class="fc" id="L321">                makeVertex(v);</span>
                
                // earlier since we didn't know when it would be processed
<span class="fc" id="L324">                endPoint(lbnd.ELedge, lbnd.ELpm, v);</span>
                
                // set the endpoint of
                // the left HalfEdge to be this vector
<span class="fc" id="L328">                endPoint(rbnd.ELedge, rbnd.ELpm, v);</span>
                
                // set the endpoint of the right HalfEdge to
                // be this vector
<span class="fc" id="L332">                ELDelete(lbnd); // mark the lowest HE for</span>
                
                // deletion - can't delete yet because there might be pointers
                // to it in Hash Map
<span class="fc" id="L336">                PQDelete(rbnd);</span>
                
                // remove all vertex events to do with the right HE
<span class="fc" id="L339">                ELDelete(rbnd); </span>
                
                // mark the right HE for
                // deletion - can't delete yet because there might be pointers
                // to it in Hash Map
                
                // set the pm variable to zero
<span class="fc" id="L346">                pm = LE;</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (bot.coord.getY() &gt; top.coord.getY()) {</span>
                    // if the site to the left of the event is 
                    // higher than the Site
                    // to the right of it, then swap them and 
                    // set the 'pm' variable to 1
<span class="fc" id="L353">                    temp = bot;</span>
<span class="fc" id="L354">                    bot = top;</span>
<span class="fc" id="L355">                    top = temp;</span>
<span class="fc" id="L356">                    pm = RE;</span>
                }
                
                // create an Edge (or line)
                // that is between the two Sites. This creates the formula of
                // the line, and assigns a line number to it
<span class="fc" id="L362">                e = bisect(bot, top); </span>
                
                // create a HE from the Edge 'e',
                // and make it point to that edge
                // with its ELedge field
<span class="fc" id="L367">                bisector = HECreate(e, pm); </span>
                
                // insert the new bisector to the
                // right of the left HE
<span class="fc" id="L371">                ELInsert(llbnd, bisector);               </span>
                
                // set one endpoint to the new edge
                // to be the vector point 'v'.
                // If the site to the left of this bisector is higher than the
                // right Site, then this endpoint
                // is put in position 0; otherwise in pos 1
<span class="fc" id="L378">                endPoint(e, RE - pm, v);</span>
                
                // if left HE and the new bisector intersect, then delete
                // the left HE, and reinsert it
<span class="fc bfc" id="L382" title="All 2 branches covered.">                if ((p = intersect(llbnd, bisector)) != null) {</span>
<span class="fc" id="L383">                    PQDelete(llbnd);</span>
<span class="fc" id="L384">                    PQInsert(llbnd, p, dist(p, bot));</span>
                }

                // if right HE and the new bisector intersect, then
                // reinsert it
<span class="fc bfc" id="L389" title="All 2 branches covered.">                if ((p = intersect(bisector, rrbnd)) != null) {</span>
<span class="fc" id="L390">                    PQInsert(bisector, p, dist(p, bot));</span>
                }
            } else {
                break;
            }
        }

<span class="fc bfc" id="L397" title="All 2 branches covered.">        for (lbnd = ELleftend.ELright; lbnd != ELrightend; </span>
<span class="fc" id="L398">            lbnd = lbnd.ELright) {</span>
            
<span class="fc" id="L400">            e = lbnd.ELedge;</span>
<span class="fc" id="L401">            clipLine(e);</span>
        }

<span class="fc" id="L404">        return true;</span>
    }

    public void plot(int fileNumber) {
        
        try {
            
<span class="nc" id="L411">            PolygonAndPointPlotter plotter =</span>
                new PolygonAndPointPlotter(xmin - 1, xmax + 1,
                    ymin - 1, ymax + 1);
        
<span class="nc" id="L415">            LinkedList&lt;GraphEdge&gt; edges = getAllEdges();</span>
<span class="nc" id="L416">            int n = 2*edges.size();</span>
<span class="nc" id="L417">            float[] xPolygon = new float[n];</span>
<span class="nc" id="L418">            float[] yPolygon = new float[n];</span>

<span class="nc" id="L420">            int count = 0;                </span>
        
<span class="nc bnc" id="L422" title="All 2 branches missed.">            for (GraphEdge edge : edges) {</span>
<span class="nc" id="L423">                int x1 = Math.round(edge.x1);</span>
<span class="nc" id="L424">                int y1 = Math.round(edge.y1);</span>
<span class="nc" id="L425">                int x2 = Math.round(edge.x2);</span>
<span class="nc" id="L426">                int y2 = Math.round(edge.y2);</span>

<span class="nc" id="L428">                PairInt p1 = new PairInt(x1, y1);</span>
<span class="nc" id="L429">                PairInt p2 = new PairInt(x2, y2);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                if (p1.equals(p2)) {</span>
<span class="nc" id="L431">                    continue;</span>
                }

<span class="nc" id="L434">                float xp = p1.getX();</span>
<span class="nc" id="L435">                float yp = p1.getY();</span>
<span class="nc" id="L436">                xPolygon[count] = xp;</span>
<span class="nc" id="L437">                yPolygon[count] = yp;</span>
<span class="nc" id="L438">                count++;</span>
                
<span class="nc" id="L440">                xp = p2.getX();</span>
<span class="nc" id="L441">                yp = p2.getY();</span>
<span class="nc" id="L442">                xPolygon[count] = xp;</span>
<span class="nc" id="L443">                yPolygon[count] = yp;</span>
<span class="nc" id="L444">                count++;</span>
<span class="nc" id="L445">            }</span>
            
<span class="nc" id="L447">            xPolygon = Arrays.copyOf(xPolygon, count);</span>
<span class="nc" id="L448">            yPolygon = Arrays.copyOf(yPolygon, count);</span>
            
<span class="nc" id="L450">            n = sites.length;</span>
<span class="nc" id="L451">            float[] x = new float[n];</span>
<span class="nc" id="L452">            float[] y = new float[n];</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L454">                Site site = sites[i];</span>
<span class="nc" id="L455">                x[i] = site.coord.getX();</span>
<span class="nc" id="L456">                y[i] = site.coord.getY();</span>
            }
            
<span class="nc" id="L459">            plotter.addPlotWithLines(x, y, xPolygon, yPolygon,</span>
                &quot;edges&quot;);
            
<span class="nc" id="L462">            plotter.writeFile(fileNumber);</span>
            
<span class="nc" id="L464">        } catch(IOException e) {</span>
<span class="nc" id="L465">            System.err.println(e.getMessage());</span>
<span class="nc" id="L466">        }</span>
<span class="nc" id="L467">    }</span>

    private class SiteComp implements Comparator&lt;Site&gt; {
        @Override
        public int compare(Site o1, Site o2) {
            if (o1.coord.getY() &lt; o2.coord.getY()) {
                return -1;
            } else if (o1.coord.getY() &gt; o2.coord.getY()) {
                return 1;
            } else if (o1.coord.getX() &lt; o2.coord.getX()) {
                return -1;
            } else if (o1.coord.getX() &gt; o2.coord.getX()) {
                return 1;
            }
            return 0;
        }
    }

    private void qsort(Site[] sites) {
<span class="fc" id="L486">        SiteComp comp = new SiteComp();</span>
<span class="fc" id="L487">        Arrays.sort(sites, comp);</span>
<span class="fc" id="L488">    }</span>
    
    public class Site {
        PairFloat coord;
        int	sitenbr;
	    int	refcnt;
        public PairFloat getCoord() {
            return coord;
        }
    }

    private class Edge {
        float a = 0;
        float b = 0;
        float c = 0;
	    Site[] ep = new Site[2];
	    Site[] reg = new Site[2];
	    int edgenbr;
    }
    
    public class GraphEdge {
        public float x1, y1, x2, y2;
	    public int site1;
        public int site2;
    }
     
    private class HalfEdge {
	    HalfEdge ELleft = null; 
        HalfEdge ELright = null;
	    Edge ELedge = null;
        boolean deleted;
	    int ELpm;
	    Site vertex = null;
	    float ystar;
	    HalfEdge PQnext = null;
    }

    // return a single in-storage site
    private Site nextOne() {
        Site s;
<span class="fc bfc" id="L528" title="All 2 branches covered.">        if (siteIdx &lt; nSites) {</span>
<span class="fc" id="L529">            s = sites[siteIdx];</span>
<span class="fc" id="L530">            siteIdx += 1;</span>
<span class="fc" id="L531">            return (s);</span>
        } else {
<span class="fc" id="L533">            return (null);</span>
        }
    }

    private Edge bisect(Site s1, Site s2) {
        float dx, dy, adx, ady;
        Edge newEdge;

<span class="fc" id="L541">        newEdge = new Edge();</span>

        // store the sites that this edge is bisecting
<span class="fc" id="L544">        newEdge.reg[0] = s1;</span>
<span class="fc" id="L545">        newEdge.reg[1] = s2;</span>
        // to begin with, there are no endpoints on the bisector - it goes to
        // infinity
<span class="fc" id="L548">        newEdge.ep[0] = null;</span>
<span class="fc" id="L549">        newEdge.ep[1] = null;</span>

        // get the difference in x dist between the sites
<span class="fc" id="L552">        dx = s2.coord.getX() - s1.coord.getX();</span>
<span class="fc" id="L553">        dy = s2.coord.getY() - s1.coord.getY();</span>
    
        // make sure that the difference in positive
<span class="fc bfc" id="L556" title="All 2 branches covered.">        adx = dx &gt; 0 ? dx : -dx;</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">        ady = dy &gt; 0 ? dy : -dy;</span>
        
        // get the slope of the line
<span class="fc" id="L560">        newEdge.c = </span>
<span class="fc" id="L561">            (s1.coord.getX() * dx + s1.coord.getY() </span>
                * dy + (dx * dx + dy
                * dy) * 0.5f);

<span class="fc bfc" id="L565" title="All 2 branches covered.">        if (adx &gt; ady) {</span>
            // set formula of line, with x fixed to 1
<span class="fc" id="L567">            newEdge.a = 1.0f;</span>
<span class="fc" id="L568">            newEdge.b = dy / dx;</span>
<span class="fc" id="L569">            newEdge.c /= dx;</span>
        } else {
            // set formula of line, with y fixed to 1
<span class="fc" id="L572">            newEdge.b = 1.0f;</span>
<span class="fc" id="L573">            newEdge.a = dx / dy;</span>
<span class="fc" id="L574">            newEdge.c /= dy;</span>
        }

<span class="fc" id="L577">        newEdge.edgenbr = nEdges;</span>

<span class="fc" id="L579">        nEdges += 1;</span>
        
<span class="fc" id="L581">        return newEdge;</span>
    }
    
    public Site[] getSites() {
<span class="fc" id="L585">        return sites;</span>
    }

    private void makeVertex(Site v) {
<span class="fc" id="L589">        v.sitenbr = nVertices;</span>
<span class="fc" id="L590">        nVertices += 1;</span>
<span class="fc" id="L591">    }</span>

    private void PQInitialize() {
<span class="fc" id="L594">        PQcount = 0;</span>
<span class="fc" id="L595">        PQmin = 0;</span>
<span class="fc" id="L596">        PQhashsize = 4 * sqrtNSites;</span>
<span class="fc" id="L597">        PQhash = new HalfEdge[PQhashsize];</span>

<span class="fc bfc" id="L599" title="All 2 branches covered.">        for (int i = 0; i &lt; PQhashsize; i += 1) {</span>
<span class="fc" id="L600">            PQhash[i] = new HalfEdge();</span>
        }
<span class="fc" id="L602">    }</span>

    private int PQBucket(HalfEdge he) {
        int bucket;

<span class="fc" id="L607">        bucket = (int) ((he.ystar - ymin) / deltay * PQhashsize);</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (bucket &lt; 0) {</span>
<span class="nc" id="L609">            bucket = 0;</span>
        }
<span class="fc bfc" id="L611" title="All 2 branches covered.">        if (bucket &gt;= PQhashsize) {</span>
<span class="fc" id="L612">            bucket = PQhashsize - 1;</span>
        }
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (bucket &lt; PQmin) {</span>
<span class="fc" id="L615">            PQmin = bucket;</span>
        }
<span class="fc" id="L617">        return bucket;</span>
    }

    // push the HalfEdge into the ordered linked list of vertices
    private void PQInsert(HalfEdge he, Site v, float offset) {
        
        HalfEdge last;
        HalfEdge next;

<span class="fc" id="L626">        he.vertex = v;</span>
<span class="fc" id="L627">        he.ystar = (v.coord.getY() + offset);</span>
<span class="fc" id="L628">        last = PQhash[PQBucket(he)];</span>
  
        // TODO: for the cases where the number
        //  of items in the linked list is getting
        //  large enough that this is not approx O(1),
        //  could initialize a specialized comparator
        //  with v.coord.getX()
        //  and store the nodes in a java LinkedList in this bin
        //  instead of a linked list
        //  and use Collections.binarySearch and the comparator with
        //  a small scan to find the last node matching
        // the criteria.
<span class="fc bfc" id="L640" title="All 6 branches covered.">        while ((next = last.PQnext) != null</span>
            &amp;&amp; (he.ystar &gt; next.ystar
               || (he.ystar == next.ystar
<span class="fc bfc" id="L643" title="All 2 branches covered.">               &amp;&amp; v.coord.getX() &gt; next.vertex.coord.getX()))) {</span>
<span class="fc" id="L644">            last = next;</span>
        }
<span class="fc" id="L646">        he.PQnext = last.PQnext;</span>
<span class="fc" id="L647">        last.PQnext = he;</span>
<span class="fc" id="L648">        PQcount += 1;</span>
<span class="fc" id="L649">    }</span>

    // remove the HalfEdge from the list of vertices
    private void PQDelete(HalfEdge he) {
        
        HalfEdge last;

<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (he.vertex != null) {</span>
<span class="fc" id="L657">            last = PQhash[PQBucket(he)];</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">            while (last.PQnext != he) {</span>
<span class="fc" id="L659">                last = last.PQnext;</span>
            }

<span class="fc" id="L662">            last.PQnext = he.PQnext;</span>
<span class="fc" id="L663">            PQcount -= 1;</span>
<span class="fc" id="L664">            he.vertex = null;</span>
        }
<span class="fc" id="L666">    }</span>

    private boolean PQEmpty() {
<span class="fc bfc" id="L669" title="All 2 branches covered.">        return (PQcount == 0);</span>
    }

    private PairFloat PQMin() {
        
<span class="fc bfc" id="L674" title="All 2 branches covered.">        while (PQhash[PQmin].PQnext == null) {</span>
<span class="fc" id="L675">            PQmin += 1;</span>
        }
        
<span class="fc" id="L678">        PairFloat answer = new PairFloat(</span>
<span class="fc" id="L679">            PQhash[PQmin].PQnext.vertex.coord.getX(),</span>
            PQhash[PQmin].PQnext.ystar);
        
<span class="fc" id="L682">        return answer;</span>
    }

    private HalfEdge PQExtractMin() {
        HalfEdge curr;

<span class="fc" id="L688">        curr = PQhash[PQmin].PQnext;</span>
<span class="fc" id="L689">        PQhash[PQmin].PQnext = curr.PQnext;</span>
<span class="fc" id="L690">        PQcount -= 1;</span>
<span class="fc" id="L691">        return curr;</span>
    }

    private HalfEdge HECreate(Edge e, int pm) {
        HalfEdge answer;
<span class="fc" id="L696">        answer = new HalfEdge();</span>
<span class="fc" id="L697">        answer.ELedge = e;</span>
<span class="fc" id="L698">        answer.ELpm = pm;</span>
<span class="fc" id="L699">        answer.PQnext = null;</span>
<span class="fc" id="L700">        answer.vertex = null;</span>
<span class="fc" id="L701">        return answer;</span>
    }

    private void ELInitialize() {
        
<span class="fc" id="L706">        ELhashsize = 2 * sqrtNSites;</span>
<span class="fc" id="L707">        ELhash = new HalfEdge[ELhashsize];</span>

<span class="fc" id="L709">        ELleftend = HECreate(null, 0);</span>
<span class="fc" id="L710">        ELrightend = HECreate(null, 0);</span>
        
<span class="fc" id="L712">        ELleftend.ELleft = null;</span>
<span class="fc" id="L713">        ELleftend.ELright = ELrightend;</span>
<span class="fc" id="L714">        ELrightend.ELleft = ELleftend;</span>
<span class="fc" id="L715">        ELrightend.ELright = null;</span>
        
<span class="fc" id="L717">        ELhash[0] = ELleftend;</span>
<span class="fc" id="L718">        ELhash[ELhashsize - 1] = ELrightend;</span>
<span class="fc" id="L719">    }</span>

    private Site leftReg(HalfEdge he) {
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        if (he.ELedge == null) {</span>
<span class="nc" id="L723">            return bottomsite;</span>
        }
<span class="fc bfc" id="L725" title="All 2 branches covered.">        return he.ELpm == LE ? he.ELedge.reg[LE] : </span>
            he.ELedge.reg[RE];
    }

    private void ELInsert(HalfEdge lb, HalfEdge newHe) {
<span class="fc" id="L730">        newHe.ELleft = lb;</span>
<span class="fc" id="L731">        newHe.ELright = lb.ELright;</span>
<span class="fc" id="L732">        (lb.ELright).ELleft = newHe;</span>
<span class="fc" id="L733">        lb.ELright = newHe;</span>
<span class="fc" id="L734">    }</span>

    /*
     * This delete routine can't reclaim node, since pointers from hash table
     * may be present.
     */
    private void ELDelete(HalfEdge he) {
<span class="fc" id="L741">        (he.ELleft).ELright = he.ELright;</span>
<span class="fc" id="L742">        (he.ELright).ELleft = he.ELleft;</span>
<span class="fc" id="L743">        he.deleted = true;</span>
<span class="fc" id="L744">    }</span>

    // Get entry from hash table, pruning any deleted nodes
    private HalfEdge ELGetHash(int b) {
        HalfEdge he;

<span class="pc bpc" id="L750" title="2 of 4 branches missed.">        if (b &lt; 0 || b &gt;= ELhashsize) {</span>
<span class="nc" id="L751">            return null;</span>
        }
<span class="fc" id="L753">        he = ELhash[b];</span>
<span class="fc bfc" id="L754" title="All 4 branches covered.">        if (he == null || !he.deleted) {</span>
<span class="fc" id="L755">            return he;</span>
        }

        // Hash table points to deleted half edge. Patch 
        // as necessary.
<span class="fc" id="L760">        ELhash[b] = null;</span>
        
<span class="fc" id="L762">        return null;</span>
    }

    private HalfEdge ELLeftBnd(PairFloat p) {
        int i, bucket;
        HalfEdge he;

        // Use hash table to get close to desired halfedge
        // use the hash function to find the place in the hash map that this
        // HalfEdge should be
<span class="fc" id="L772">        bucket = (int) ((p.getX() - xmin) / deltax * ELhashsize);</span>

        // make sure that the bucket position in within the range of the hash
        // array
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">        if (bucket &lt; 0) {</span>
<span class="nc" id="L777">            bucket = 0;</span>
        }
<span class="fc bfc" id="L779" title="All 2 branches covered.">        if (bucket &gt;= ELhashsize) {</span>
<span class="fc" id="L780">            bucket = ELhashsize - 1;</span>
        }

<span class="fc" id="L783">        he = ELGetHash(bucket);</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (he == null) {</span>
            
            //TODO: could improve this with a datastructure
            // that has predecessor and successor
            
            // if the HE isn't found, search backwards and forwards in the hash map
            // for the first non-null entry
        
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">            for (i = 1; i &lt; ELhashsize; i += 1) {</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">                if ((he = ELGetHash(bucket - i)) != null) {</span>
<span class="fc" id="L794">                    break;</span>
                }
<span class="fc bfc" id="L796" title="All 2 branches covered.">                if ((he = ELGetHash(bucket + i)) != null) {</span>
<span class="fc" id="L797">                    break;</span>
                }
            }
        }
        
        // Now search linear list of halfedges for the correct one
<span class="fc bfc" id="L803" title="All 4 branches covered.">        if (he == ELleftend || </span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">        (he != ELrightend &amp;&amp; rightOf(he, p))) {</span>
            // keep going right on the list until either the end is reached, or
            // you find the 1st edge which the point isn't to the right of
            do {
<span class="fc" id="L808">                he = he.ELright;</span>
<span class="fc bfc" id="L809" title="All 4 branches covered.">            } while (he != ELrightend &amp;&amp; rightOf(he, p));</span>
<span class="fc" id="L810">            he = he.ELleft;</span>
        } else {
            // if the point is to the left of the HalfEdge, then search left for
            // the HE just to the left of the point
        
            do {
<span class="fc" id="L816">                he = he.ELleft;</span>
<span class="fc bfc" id="L817" title="All 4 branches covered.">            } while (he != ELleftend &amp;&amp; !rightOf(he, p));</span>
        }

        // Update hash table and reference counts
<span class="fc bfc" id="L821" title="All 4 branches covered.">        if (bucket &gt; 0 &amp;&amp; bucket &lt; ELhashsize - 1) {</span>
<span class="fc" id="L822">            ELhash[bucket] = he;</span>
        }
<span class="fc" id="L824">        return he;</span>
    }

    private void pushGraphEdge(Site leftSite, Site rightSite, 
        float x1, float y1, float x2, float y2) {
      
<span class="fc" id="L830">        GraphEdge newEdge = new GraphEdge();</span>
<span class="fc" id="L831">        allEdges.add(newEdge);</span>
<span class="fc" id="L832">        newEdge.x1 = x1;</span>
<span class="fc" id="L833">        newEdge.y1 = y1;</span>
<span class="fc" id="L834">        newEdge.x2 = x2;</span>
<span class="fc" id="L835">        newEdge.y2 = y2;</span>

<span class="fc" id="L837">        newEdge.site1 = leftSite.sitenbr;</span>
<span class="fc" id="L838">        newEdge.site2 = rightSite.sitenbr;</span>
<span class="fc" id="L839">    }</span>

    private void clipLine(Edge e) {
        float pxmin, pxmax, pymin, pymax;
        Site s1, s2;
<span class="fc" id="L844">        float x1 = 0, x2 = 0, y1 = 0, y2 = 0;</span>

<span class="fc" id="L846">        x1 = e.reg[0].coord.getX();</span>
<span class="fc" id="L847">        x2 = e.reg[1].coord.getX();</span>
<span class="fc" id="L848">        y1 = e.reg[0].coord.getY();</span>
<span class="fc" id="L849">        y2 = e.reg[1].coord.getY();</span>

        // if the distance between the two points this line 
        // was created from is
        // less than the square root of 2, then ignore it
<span class="fc bfc" id="L854" title="All 2 branches covered.">        if (Math.sqrt(((x2 - x1) * (x2 - x1)) </span>
            + ((y2 - y1) * (y2 - y1))) &lt; minDistanceBetweenSites) {
<span class="fc" id="L856">            return;</span>
        }
<span class="fc" id="L858">        pxmin = borderMinX;</span>
<span class="fc" id="L859">        pxmax = borderMaxX;</span>
<span class="fc" id="L860">        pymin = borderMinY;</span>
<span class="fc" id="L861">        pymax = borderMaxY;</span>

<span class="fc bfc" id="L863" title="All 4 branches covered.">        if (e.a == 1.0 &amp;&amp; e.b &gt;= 0.0) {</span>
<span class="fc" id="L864">            s1 = e.ep[1];</span>
<span class="fc" id="L865">            s2 = e.ep[0];</span>
        } else {
<span class="fc" id="L867">            s1 = e.ep[0];</span>
<span class="fc" id="L868">            s2 = e.ep[1];</span>
        }

<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (e.a == 1.0) {</span>
<span class="fc" id="L872">            y1 = pymin;</span>
<span class="fc bfc" id="L873" title="All 4 branches covered.">            if (s1 != null &amp;&amp; s1.coord.getY() &gt; pymin) {</span>
<span class="fc" id="L874">                y1 = s1.coord.getY();</span>
            }
<span class="fc bfc" id="L876" title="All 2 branches covered.">            if (y1 &gt; pymax) {</span>
<span class="fc" id="L877">                y1 = pymax;</span>
            }
<span class="fc" id="L879">            x1 = e.c - e.b * y1;</span>
<span class="fc" id="L880">            y2 = pymax;</span>
<span class="fc bfc" id="L881" title="All 4 branches covered.">            if (s2 != null &amp;&amp; s2.coord.getY() &lt; pymax) {</span>
<span class="fc" id="L882">                y2 = s2.coord.getY();</span>
            }

<span class="fc bfc" id="L885" title="All 2 branches covered.">            if (y2 &lt; pymin) {</span>
<span class="fc" id="L886">                y2 = pymin;</span>
            }
<span class="fc" id="L888">            x2 = (e.c) - (e.b) * y2;</span>
<span class="fc bfc" id="L889" title="All 10 branches covered.">            if (((x1 &gt; pxmax) &amp; (x2 &gt; pxmax)) | ((x1 &lt; pxmin) &amp; (x2 &lt; pxmin))) {</span>
<span class="fc" id="L890">                return;</span>
            }
<span class="fc bfc" id="L892" title="All 2 branches covered.">            if (x1 &gt; pxmax) {</span>
<span class="fc" id="L893">                x1 = pxmax;</span>
<span class="fc" id="L894">                y1 = (e.c - x1) / e.b;</span>
            }
<span class="fc bfc" id="L896" title="All 2 branches covered.">            if (x1 &lt; pxmin) {</span>
<span class="fc" id="L897">                x1 = pxmin;</span>
<span class="fc" id="L898">                y1 = (e.c - x1) / e.b;</span>
            }
<span class="fc bfc" id="L900" title="All 2 branches covered.">            if (x2 &gt; pxmax) {</span>
<span class="fc" id="L901">                x2 = pxmax;</span>
<span class="fc" id="L902">                y2 = (e.c - x2) / e.b;</span>
            }
<span class="fc bfc" id="L904" title="All 2 branches covered.">            if (x2 &lt; pxmin) {</span>
<span class="fc" id="L905">                x2 = pxmin;</span>
<span class="fc" id="L906">                y2 = (e.c - x2) / e.b;</span>
            }
        } else {
<span class="fc" id="L909">            x1 = pxmin;</span>
<span class="fc bfc" id="L910" title="All 4 branches covered.">            if (s1 != null &amp;&amp; s1.coord.getX() &gt; pxmin) {</span>
<span class="fc" id="L911">                x1 = s1.coord.getX();</span>
            }
<span class="fc bfc" id="L913" title="All 2 branches covered.">            if (x1 &gt; pxmax) {</span>
<span class="fc" id="L914">                x1 = pxmax;</span>
            }
<span class="fc" id="L916">            y1 = e.c - e.a * x1;</span>
<span class="fc" id="L917">            x2 = pxmax;</span>
<span class="fc bfc" id="L918" title="All 4 branches covered.">            if (s2 != null &amp;&amp; s2.coord.getX() &lt; pxmax) {</span>
<span class="fc" id="L919">                x2 = s2.coord.getX();</span>
            }
<span class="fc bfc" id="L921" title="All 2 branches covered.">            if (x2 &lt; pxmin) {</span>
<span class="fc" id="L922">                x2 = pxmin;</span>
            }
<span class="fc" id="L924">            y2 = e.c - e.a * x2;</span>
<span class="fc bfc" id="L925" title="All 10 branches covered.">            if (((y1 &gt; pymax) &amp; (y2 &gt; pymax)) | ((y1 &lt; pymin) &amp; (y2 &lt; pymin))) {</span>
<span class="fc" id="L926">                return;</span>
            }
<span class="fc bfc" id="L928" title="All 2 branches covered.">            if (y1 &gt; pymax) {</span>
<span class="fc" id="L929">                y1 = pymax;</span>
<span class="fc" id="L930">                x1 = (e.c - y1) / e.a;</span>
            }
<span class="fc bfc" id="L932" title="All 2 branches covered.">            if (y1 &lt; pymin) {</span>
<span class="fc" id="L933">                y1 = pymin;</span>
<span class="fc" id="L934">                x1 = (e.c - y1) / e.a;</span>
            }
<span class="fc bfc" id="L936" title="All 2 branches covered.">            if (y2 &gt; pymax) {</span>
<span class="fc" id="L937">                y2 = pymax;</span>
<span class="fc" id="L938">                x2 = (e.c - y2) / e.a;</span>
            }
<span class="fc bfc" id="L940" title="All 2 branches covered.">            if (y2 &lt; pymin) {</span>
<span class="fc" id="L941">                y2 = pymin;</span>
<span class="fc" id="L942">                x2 = (e.c - y2) / e.a;</span>
            }
        }
        
<span class="fc" id="L946">        float diffX = x2 - x1;</span>
<span class="fc" id="L947">        float diffY = y2 - y1;</span>
        //this, unfortunately, removes possible edges for
        // points composed of only a straight line
        //if (diffX == 0.f &amp;&amp; diffY == 0.f) {
        //    return;
        //}
<span class="fc bfc" id="L953" title="All 2 branches covered.">        if (Math.sqrt((diffX * diffX) + (diffY * diffY)) </span>
            &lt; minDistanceBetweenSites) {
<span class="fc" id="L955">            return;</span>
        }
        
<span class="fc" id="L958">        pushGraphEdge(e.reg[0], e.reg[1], x1, y1, x2, y2);</span>
<span class="fc" id="L959">    }</span>

    private void endPoint(Edge e, int lr, Site s) {
<span class="fc" id="L962">        e.ep[lr] = s;</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">        if (e.ep[RE - lr] == null) {</span>
<span class="fc" id="L964">            return;</span>
        }
<span class="fc" id="L966">        clipLine(e);</span>
<span class="fc" id="L967">    }</span>

    // returns 1 if p is to right of halfedge e
    private boolean rightOf(HalfEdge el, PairFloat p) {
        Edge e;
        Site topsite;
        boolean rightOfSite;
        boolean above, fast;
        float dxp, dyp, dxs, t1, t2, t3, yl;

<span class="fc" id="L977">        e = el.ELedge;</span>
<span class="fc" id="L978">        topsite = e.reg[1];</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">        if (p.getX() &gt; topsite.coord.getX()) {</span>
<span class="fc" id="L980">            rightOfSite = true;</span>
        } else {
<span class="fc" id="L982">            rightOfSite = false;</span>
        }
<span class="fc bfc" id="L984" title="All 4 branches covered.">        if (rightOfSite &amp;&amp; el.ELpm == LE) {</span>
<span class="fc" id="L985">            return true;</span>
        }
<span class="fc bfc" id="L987" title="All 4 branches covered.">        if (!rightOfSite &amp;&amp; el.ELpm == RE) {</span>
<span class="fc" id="L988">            return false;</span>
        }

<span class="fc bfc" id="L991" title="All 2 branches covered.">        if (e.a == 1.0) {</span>
<span class="fc" id="L992">            dyp = p.getY() - topsite.coord.getY();</span>
<span class="fc" id="L993">            dxp = p.getX() - topsite.coord.getX();</span>
<span class="fc" id="L994">            fast = false;</span>
<span class="fc bfc" id="L995" title="All 8 branches covered.">            if ((!rightOfSite &amp; (e.b &lt; 0.0)) | (rightOfSite &amp; (e.b &gt;= 0.0))) {</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">                above = dyp &gt;= e.b * dxp;</span>
<span class="fc" id="L997">                fast = above;</span>
            } else {
<span class="fc bfc" id="L999" title="All 2 branches covered.">                above = p.getX() + p.getY() * e.b &gt; e.c;</span>
<span class="fc bfc" id="L1000" title="All 2 branches covered.">                if (e.b &lt; 0.0) {</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">                    above = !above;</span>
                }
<span class="fc bfc" id="L1003" title="All 2 branches covered.">                if (!above) {</span>
<span class="fc" id="L1004">                    fast = true;</span>
                }
            }
<span class="fc bfc" id="L1007" title="All 2 branches covered.">            if (!fast) {</span>
<span class="fc" id="L1008">                dxs = topsite.coord.getX() - (e.reg[0]).coord.getX();</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">                above = e.b * (dxp * dxp - dyp * dyp) &lt; dxs * dyp</span>
                    * (1.0 + 2.0 * dxp / dxs + e.b * e.b);
<span class="fc bfc" id="L1011" title="All 2 branches covered.">                if (e.b &lt; 0.0) {</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">                    above = !above;</span>
                }
            }
        } else /* e.b==1.0 */ {
<span class="fc" id="L1016">            yl = e.c - e.a * p.getX();</span>
<span class="fc" id="L1017">            t1 = p.getY() - yl;</span>
<span class="fc" id="L1018">            t2 = p.getX() - topsite.coord.getX();</span>
<span class="fc" id="L1019">            t3 = yl - topsite.coord.getY();</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">            above = t1 * t1 &gt; t2 * t2 + t3 * t3;</span>
        }
<span class="fc bfc" id="L1022" title="All 4 branches covered.">        return el.ELpm == LE ? above : !above;</span>
    }

    private Site rightReg(HalfEdge he) {
<span class="fc bfc" id="L1026" title="All 2 branches covered.">        if (he.ELedge == (Edge) null) {</span>
            // if this halfedge has no edge, return the bottom site (whatever
            // that is)
        
<span class="fc" id="L1030">            return bottomsite;</span>
        }

        // if the ELpm field is zero, return the site 0 that this edge bisects,
        // otherwise return site number 1
<span class="fc bfc" id="L1035" title="All 2 branches covered.">        return he.ELpm == LE ? he.ELedge.reg[RE] : </span>
            he.ELedge.reg[LE];
    }

    private float dist(Site s, Site t) {
        float dx, dy;
<span class="fc" id="L1041">        dx = s.coord.getX() - t.coord.getX();</span>
<span class="fc" id="L1042">        dy = s.coord.getY() - t.coord.getY();</span>
<span class="fc" id="L1043">        return (float) (Math.sqrt(dx * dx + dy * dy));</span>
    }

    // create a new site where the HalfEdges el1 and el2 intersect - note that
    // the Point in the argument list is not used, don't know why it's there
    private Site intersect(HalfEdge el1, HalfEdge el2) {
        Edge e1, e2, e;
        HalfEdge el;
        float d, xint, yint;
        boolean rightOfSite;
        Site v;

<span class="fc" id="L1055">        e1 = el1.ELedge;</span>
<span class="fc" id="L1056">        e2 = el2.ELedge;</span>
<span class="fc bfc" id="L1057" title="All 4 branches covered.">        if (e1 == null || e2 == null) {</span>
<span class="fc" id="L1058">            return null;</span>
        }

        // if the two edges bisect the same parent, return null
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        if (e1.reg[1].equals(e2.reg[1])) {</span>
<span class="fc" id="L1063">            return null;</span>
        }

<span class="fc" id="L1066">        d = e1.a * e2.b - e1.b * e2.a;</span>
<span class="fc bfc" id="L1067" title="All 4 branches covered.">        if (-1.0e-10 &lt; d &amp;&amp; d &lt; 1.0e-10) {</span>
<span class="fc" id="L1068">            return null;</span>
        }

<span class="fc" id="L1071">        xint = (e1.c * e2.b - e2.c * e1.b) / d;</span>
<span class="fc" id="L1072">        yint = (e2.c * e1.a - e1.c * e2.a) / d;</span>

<span class="fc bfc" id="L1074" title="All 2 branches covered.">        if ((e1.reg[1].coord.getY() &lt; e2.reg[1].coord.getY())</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">            || (e1.reg[1].coord.getY() == e2.reg[1].coord.getY() </span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">            &amp;&amp; e1.reg[1].coord.getX() &lt; e2.reg[1].coord.getX())) {</span>
<span class="fc" id="L1077">            el = el1;</span>
<span class="fc" id="L1078">            e = e1;</span>
        } else {
<span class="fc" id="L1080">            el = el2;</span>
<span class="fc" id="L1081">            e = e2;</span>
        }

<span class="fc bfc" id="L1084" title="All 2 branches covered.">        rightOfSite = xint &gt;= e.reg[1].coord.getX();</span>
<span class="fc bfc" id="L1085" title="All 8 branches covered.">        if ((rightOfSite &amp;&amp; el.ELpm == LE)</span>
            || (!rightOfSite &amp;&amp; el.ELpm == RE)) {
<span class="fc" id="L1087">            return null;</span>
        }

        // create a new site at the point of intersection - this is a new vector
        // event waiting to happen
<span class="fc" id="L1092">        v = new Site();</span>
<span class="fc" id="L1093">        v.coord = new PairFloat(xint, yint);</span>
<span class="fc" id="L1094">        return v;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>